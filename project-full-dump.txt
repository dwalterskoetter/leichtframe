===== FILE: .config/dotnet-tools.json =====
{
  "version": 1,
  "isRoot": true,
  "tools": {
    "grynwald.mddocs": {
      "version": "0.6.39",
      "commands": [
        "mddocs"
      ]
    }
  }
}
===== FILE: .github/workflows/cd.yml =====
name: LeichtFrame CD (Release)

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Version to publish (e.g. 0.1.0)"
        required: true
        default: "0.1.0-alpha"

jobs:
  publish:
    name: Publish to NuGet
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Determine Version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_ENV
            echo "Mode: Manual Release ${{ github.event.inputs.version }}"
          else
            # Extract tag version (e.g. v0.1.0 -> 0.1.0)
            echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_ENV
            echo "Mode: Tag Triggered Release"
          fi

      - name: Restore
        run: dotnet restore

      - name: Build & Test
        run: |
          dotnet build --no-restore -c Release -p:Version=$VERSION
          dotnet test --no-build -c Release

      - name: Pack
        run: dotnet pack --no-build -c Release -o nupkgs -p:Version=$VERSION

      - name: Push to NuGet
        run: |
          dotnet nuget push nupkgs/*.nupkg \
            --api-key ${{ secrets.NUGET_API_KEY }} \
            --source https://api.nuget.org/v3/index.json \
            --skip-duplicate

===== FILE: .github/workflows/ci.yml =====
name: LeichtFrame CI (Integration)

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
  workflow_dispatch:

jobs:
  build-and-test:
    name: Build & Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x
          cache: true
          cache-dependency-path: "**/*.csproj"

      - name: Restore Dependencies
        run: dotnet restore

      - name: Build
        run: dotnet build --no-restore -c Release

      - name: Test
        run: dotnet test --no-build -c Release --verbosity normal

      - name: Restore Local Tools
        run: dotnet tool restore

      - name: Verify Documentation Generation
        run: |
          chmod +x scripts/generate_docs.sh
          ./scripts/generate_docs.sh

      # We pack to ensure metadata is valid and code is packable.
      # This is a "Dry Run" - we do not publish this artifact to NuGet.org.
      - name: Pack (Dry Run)
        run: dotnet pack --no-build -c Release -o nupkgs

      - name: Upload Artifacts (Verification)
        uses: actions/upload-artifact@v4
        with:
          name: pre-release-packages
          path: nupkgs/*.nupkg
          retention-days: 1

===== FILE: .gitignore =====
## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.
##
## Get latest from `dotnet new gitignore`

# dotenv files
.env

# User-specific files
*.rsuser
*.suo
*.user
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Mono auto generated files
mono_crash.*

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Ww][Ii][Nn]32/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Ll]og/
[Ll]ogs/

# Visual Studio 2015/2017 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# Visual Studio 2017 auto generated files
Generated\ Files/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUnit
*.VisualState.xml
TestResult.xml
nunit-*.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# Benchmark Results
BenchmarkDotNet.Artifacts/

# .NET
project.lock.json
project.fragment.lock.json
artifacts/

# Tye
.tye/

# ASP.NET Scaffolding
ScaffoldingReadMe.txt

# StyleCop
StyleCopReport.xml

# Files built by Visual Studio
*_i.c
*_p.c
*_h.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*_wpftmp.csproj
*.log
*.tlog
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# Visual Studio Trace Files
*.e2e

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# --- Documentation Generation ---
# Ignore generated API docs (they are rebuilt by CI/Script)
website/docs/api/

# Ignore copied guides (they exist in /docs originally)
website/docs/guides/

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# AxoCover is a Code Coverage Tool
.axoCover/*
!.axoCover/settings.json

# Coverlet is a free, cross platform Code Coverage Tool
coverage*.json
coverage*.xml
coverage*.info

# Visual Studio code coverage results
*.coverage
*.coveragexml

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# Note: Comment the next line if you want to checkin your web deploy settings,
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# Microsoft Azure Web App publish settings. Comment the next line if you want to
# checkin your Azure Web App publish settings, but sensitive information contained
# in these scripts will be unencrypted
PublishScripts/

# NuGet Packages
*.nupkg
# NuGet Symbol Packages
*.snupkg
# The packages folder can be ignored because of Package Restore
**/[Pp]ackages/*
# except build/, which is used as an MSBuild target.
!**/[Pp]ackages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/[Pp]ackages/repositories.config
# NuGet v3's project.json files produces more ignorable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt
*.appx
*.appxbundle
*.appxupload

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!?*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.jfm
*.pfx
*.publishsettings
orleans.codegen.cs

# Including strong name files can present a security risk
# (https://github.com/github/gitignore/pull/2483#issue-259490424)
#*.snk

# Since there are multiple workflows, uncomment next line to ignore bower_components
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm
ServiceFabricBackup/
*.rptproj.bak

# SQL Server files
*.mdf
*.ldf
*.ndf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings
*.rptproj.rsuser
*- [Bb]ackup.rdl
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat
node_modules/

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
*.vbw

# Visual Studio 6 auto-generated project file (contains which files were open etc.)
*.vbp

# Visual Studio 6 workspace and project file (working project files containing files to include in project)
*.dsw
*.dsp

# Visual Studio 6 technical files
*.ncb
*.aps

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# CodeRush personal settings
.cr/personal

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Tabs Studio
*.tss

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder
.mfractor/

# Local History for Visual Studio
.localhistory/

# Visual Studio History (VSHistory) files
.vshistory/

# BeatPulse healthcheck temp database
healthchecksdb

# Backup folder for Package Reference Convert tool in Visual Studio 2017
MigrationBackup/

# Ionide (cross platform F# VS Code tools) working folder
.ionide/

# Fody - auto-generated XML schema
FodyWeavers.xsd

# VS Code files for those working on multiple tools
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
*.code-workspace

# Local History for Visual Studio Code
.history/

# Windows Installer files from build outputs
*.cab
*.msi
*.msix
*.msm
*.msp

# JetBrains Rider
*.sln.iml
.idea

##
## Visual studio for Mac
##


# globs
Makefile.in
*.userprefs
*.usertasks
config.make
config.status
aclocal.m4
install-sh
autom4te.cache/
*.tar.gz
tarballs/
test-results/

# Mac bundle stuff
*.dmg
*.app

# content below from: https://github.com/github/gitignore/blob/master/Global/macOS.gitignore
# General
.DS_Store
.AppleDouble
.LSOverride

# Icon must end with two \r
Icon


# Thumbnails
._*

# Files that might appear in the root of a volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk

# content below from: https://github.com/github/gitignore/blob/master/Global/Windows.gitignore
# Windows thumbnail cache files
Thumbs.db
ehthumbs.db
ehthumbs_vista.db

# Dump file
*.stackdump

# Folder config file
[Dd]esktop.ini

# Recycle Bin used on file shares
$RECYCLE.BIN/

# Windows Installer files
*.cab
*.msi
*.msix
*.msm
*.msp

# Windows shortcuts
*.lnk

# Vim temporary swap files
*.swp

===== FILE: CONTRIBUTING.md =====
# Contributing to LeichtFrame

Thank you for your interest in contributing to LeichtFrame! We welcome contributions from everyone, whether it's fixing a bug, improving documentation, or optimizing performance.

## üõ†Ô∏è Prerequisites

To build and run this project, you need:

- [.NET 8.0 SDK](https://dotnet.microsoft.com/download/dotnet/8.0) or newer.
- A C# IDE (Visual Studio 2022, JetBrains Rider, or VS Code).

## üöÄ Getting Started

1.  **Fork** the repository on GitHub.
2.  **Clone** your fork locally:
    ```bash
    git clone https://github.com/YOUR_USERNAME/LeichtFrame.git
    cd LeichtFrame
    ```
3.  Create a **feature branch** for your work:
    ```bash
    git checkout -b feature/my-new-optimization
    ```

## üèóÔ∏è Building and Testing

The project follows a standard .NET solution structure.

### Build

To build the entire solution (Core, IO, Benchmarks, Tests):

```bash
dotnet build -c Release
```

### Run Tests

Please ensure all unit tests pass before submitting a PR. We use xUnit.

```bash
dotnet test -c Release
```

## üìä Performance & Benchmarks

**Performance is the #1 feature of LeichtFrame.**
If you modify the Core engine or IO adapters, you **must** run the benchmarks to ensure no performance regressions occurred.

1.  Navigate to the benchmark directory:
    ```bash
    cd src/LeichtFrame.Benchmarks
    ```
2.  Run the benchmarks (this may take 5-10 minutes):
    ```bash
    dotnet run -c Release --filter "*"
    ```

Compare the results with the baseline in `README.md`. If your change makes the code slower or increases memory allocation, please explain why in your Pull Request.

For detailed profiling instructions (CPU, Memory Allocation), please refer to [docs/PROFILING.md](docs/PROFILING.md).

## üìù Coding Standards

- **Zero-Allocation:** This is critical. Avoid LINQ (`.Select()`, `.Where()`, `.ToList()`) inside hot loops. Use `Span<T>`, `ReadOnlySpan<T>`, and `for`-loops instead.
- **Style:** Follow standard C# coding conventions (PascalCase for public members, camelCase for local variables).
- **Documentation:** All public APIs must have XML documentation comments (`///`).

## ü§ù Pull Request Process

1.  Push your feature branch to your GitHub fork.
2.  Open a Pull Request against the `main` branch of the official repository.
3.  Describe your changes clearly. If it's a performance optimization, include the benchmark results.
4.  Ensure the CI pipeline (GitHub Actions) passes.

Thank you for helping make .NET data processing faster! üöÄ

===== FILE: Directory.Build.props =====
<Project>
  <PropertyGroup>
    <!-- Product Information -->
    <Version>0.2.0-alpha</Version>
    <Authors>The LeichtFrame Authors</Authors>
    <Company>LeichtFrame Open Source</Company>
    <Product>LeichtFrame</Product>
    <Description>A lightweight, high-performance DataFrame engine for .NET optimized for backend services.</Description>
    <Copyright>Copyright (c) 2025 The LeichtFrame Authors</Copyright>

    <!-- Links & License -->
    <RepositoryUrl>https://github.com/dwalterskoetter/leichtFrame</RepositoryUrl>
    <RepositoryType>git</RepositoryType>
    <PackageLicenseExpression>MIT</PackageLicenseExpression>
    <PackageTags>dataframe;data;analysis;csv;parquet;performance;span;memory</PackageTags>
    <PackageProjectUrl>https://github.com/dwalterskoetter/leichtFrame</PackageProjectUrl>
    
    <!-- Documentation & Warnings -->
    <GenerateDocumentationFile>true</GenerateDocumentationFile>

    <!-- Build Settings -->
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <LangVersion>latest</LangVersion>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <ContinuousIntegrationBuild Condition="'$(GITHUB_ACTIONS)' == 'true'">true</ContinuousIntegrationBuild>
    <EmbedUntrackedSources>true</EmbedUntrackedSources>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="SauceControl.InheritDoc" Version="2.0.1" PrivateAssets="all" />
  </ItemGroup>
</Project>
===== FILE: LICENSE =====
MIT License

Copyright (c) 2025 The LeichtFrame Authors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

===== FILE: LeichtFrame.sln =====
Ôªø
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31903.59
MinimumVisualStudioVersion = 10.0.40219.1
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "src", "src", "{72C13B89-7349-4816-BFBD-8753DD2DE863}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "LeichtFrame.Core", "src\LeichtFrame.Core\LeichtFrame.Core.csproj", "{1116D4FB-E6EA-479F-BE0B-671DCCBC3E2A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "LeichtFrame.IO", "src\LeichtFrame.IO\LeichtFrame.IO.csproj", "{793C3E75-935E-4943-9932-0038F40B6403}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "LeichtFrame.Examples", "src\LeichtFrame.Examples\LeichtFrame.Examples.csproj", "{EA990D67-CE17-43F6-9A60-1B885B613C7A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "LeichtFrame.Benchmarks", "src\LeichtFrame.Benchmarks\LeichtFrame.Benchmarks.csproj", "{597E3363-190B-4689-A582-CFCA81A78FAF}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "tests", "tests", "{B5129BFB-994E-4A31-AD58-001DAEE8BB61}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "LeichtFrame.Core.Tests", "tests\LeichtFrame.Core.Tests\LeichtFrame.Core.Tests.csproj", "{F1EC1E9D-5647-4C2E-9134-EADE0AF5E683}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "LeichtFrame.IO.Tests", "tests\LeichtFrame.IO.Tests\LeichtFrame.IO.Tests.csproj", "{E8134244-2E7E-4605-A546-15A7BA49DF99}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1116D4FB-E6EA-479F-BE0B-671DCCBC3E2A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{1116D4FB-E6EA-479F-BE0B-671DCCBC3E2A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{1116D4FB-E6EA-479F-BE0B-671DCCBC3E2A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{1116D4FB-E6EA-479F-BE0B-671DCCBC3E2A}.Release|Any CPU.Build.0 = Release|Any CPU
		{793C3E75-935E-4943-9932-0038F40B6403}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{793C3E75-935E-4943-9932-0038F40B6403}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{793C3E75-935E-4943-9932-0038F40B6403}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{793C3E75-935E-4943-9932-0038F40B6403}.Release|Any CPU.Build.0 = Release|Any CPU
		{EA990D67-CE17-43F6-9A60-1B885B613C7A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{EA990D67-CE17-43F6-9A60-1B885B613C7A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{EA990D67-CE17-43F6-9A60-1B885B613C7A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{EA990D67-CE17-43F6-9A60-1B885B613C7A}.Release|Any CPU.Build.0 = Release|Any CPU
		{597E3363-190B-4689-A582-CFCA81A78FAF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{597E3363-190B-4689-A582-CFCA81A78FAF}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{597E3363-190B-4689-A582-CFCA81A78FAF}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{597E3363-190B-4689-A582-CFCA81A78FAF}.Release|Any CPU.Build.0 = Release|Any CPU
		{F1EC1E9D-5647-4C2E-9134-EADE0AF5E683}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F1EC1E9D-5647-4C2E-9134-EADE0AF5E683}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F1EC1E9D-5647-4C2E-9134-EADE0AF5E683}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F1EC1E9D-5647-4C2E-9134-EADE0AF5E683}.Release|Any CPU.Build.0 = Release|Any CPU
		{E8134244-2E7E-4605-A546-15A7BA49DF99}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E8134244-2E7E-4605-A546-15A7BA49DF99}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E8134244-2E7E-4605-A546-15A7BA49DF99}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E8134244-2E7E-4605-A546-15A7BA49DF99}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{1116D4FB-E6EA-479F-BE0B-671DCCBC3E2A} = {72C13B89-7349-4816-BFBD-8753DD2DE863}
		{793C3E75-935E-4943-9932-0038F40B6403} = {72C13B89-7349-4816-BFBD-8753DD2DE863}
		{EA990D67-CE17-43F6-9A60-1B885B613C7A} = {72C13B89-7349-4816-BFBD-8753DD2DE863}
		{597E3363-190B-4689-A582-CFCA81A78FAF} = {72C13B89-7349-4816-BFBD-8753DD2DE863}
		{F1EC1E9D-5647-4C2E-9134-EADE0AF5E683} = {B5129BFB-994E-4A31-AD58-001DAEE8BB61}
		{E8134244-2E7E-4605-A546-15A7BA49DF99} = {B5129BFB-994E-4A31-AD58-001DAEE8BB61}
	EndGlobalSection
EndGlobal

===== FILE: README.md =====
# LeichtFrame üöÄ

![Build Status](https://github.com/dwalterskoetter/leichtFrame/actions/workflows/ci.yml/badge.svg)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)
[![NuGet](https://img.shields.io/nuget/v/LeichtFrame.Core.svg)](https://www.nuget.org/packages/LeichtFrame.Core/)

**LeichtFrame** is a high‚Äëperformance, zero‚Äëallocation DataFrame engine for **.NET 8+**, designed for **backend and SaaS workloads**.

Unlike typical data‚Äëscience tools, LeichtFrame focuses on minimal memory usage, strict schema typing, and native integration with modern .NET APIs (`Span<T>`, `Memory<T>`, `System.Text.Json`).

---

## Table of Contents

- [Why LeichtFrame?](#-why-leichtframe)
- [Highlights](#-highlights)
- [Benchmarks](#-benchmarks)
- [Installation](#-installation)
- [Quickstart (Example)](#-quickstart-example)
- [Roadmap (MVP Status)](#-roadmap-mvp-status)
- [Contributing](#-contributing)
- [License](#-license)

---

## ‚ö° Why LeichtFrame?

- **Zero‚ÄëCopy Slicing** ‚Äî Create views, filters, and projections without allocating new buffers.
- **Columnar Storage** ‚Äî Contiguous memory (Structure of Arrays) for SIMD usage & better cache locality.
- **Backend‚ÄëReady** ‚Äî Built for highly concurrent web APIs, not Jupyter notebooks.
- **Interoperability** ‚Äî Native support for **Apache Arrow**, **Parquet**, and efficient CSV streaming.

---

## üìä Benchmarks

_Scenario: Processing 1,000,000 rows (Integer Columns)._

| Operation             | LeichtFrame üöÄ | LINQ (Standard) | Microsoft.Data.Analysis | Verdict                    |
| :-------------------- | :------------- | :-------------- | :---------------------- | :------------------------- |
| **Sum (Aggregation)** | **555 Œºs**     | 1,195 Œºs        | 995 Œºs                  | **2.1x faster** than LINQ  |
| **Join (Inner)**      | **349 ms**     | 364 ms          | 520 ms                  | **Faster** than LINQ & MDA |
| **Filter (Where)**    | **37 ms**      | 13 ms           | 56 ms                   | **1.5x faster** than MDA   |
| **Memory (Filter)**   | **6.2 MB**     | 8.4 MB          | 9.8 MB                  | **Lowest Allocation**      |

> **Environment:**  
> üíª **CPU:** Intel Core i9-13900H (13th Gen)  
> üêß **OS:** Linux Mint 22.2  
> üîß **Runtime:** .NET 8.0.21 (x64 RyuJIT)  
> üìÖ **Date:** Dec 2025  
> _Verified via [BenchmarkDotNet](https://github.com/dotnet/BenchmarkDotNet)._

---

## üì¶ Installation

LeichtFrame is available on NuGet (Alpha):

```bash
# Core Engine
dotnet add package LeichtFrame.Core

# IO Adapters (CSV, Parquet, Arrow)
dotnet add package LeichtFrame.IO
```

---

## üìò Quickstart Example (End‚Äëto‚ÄëEnd)

LeichtFrame allows you to define your schema using standard C# classes (POCOs) ‚Äî similar to `CsvHelper` or `EF Core`.

Read CSV ‚Üí Filter ‚Üí Aggregate ‚Üí Export to Parquet.

```csharp
using System;
using LeichtFrame.Core;
using LeichtFrame.IO;

// 1. Define your data structure
public class SalesRecord
{
    public string Department { get; set; }
    public double Sales { get; set; }
    public bool IsActive { get; set; }
}

class Example
{
    static void Main()
    {
        // 2. Read CSV (Schema is inferred from the class üöÄ)
        var df = CsvReader.Read<SalesRecord>("data.csv");

        // 3. High-Performance Filtering (Zero-Allocation view)
        var activeSales = df.Where(row => row.Get<bool>("IsActive"));

        // 4. Aggregation
        var totalVolume = activeSales.Sum("Sales");
        Console.WriteLine($"Total Sales Volume: {totalVolume}");

        // 5. Export to Parquet (Big Data ready)
        activeSales.WriteParquet("report.parquet");
    }
}
```

---

## üó∫Ô∏è Roadmap (MVP Status)

**Core**

- Columnar Memory
- Schema
- Zero‚ÄëCopy Slicing

**API**

- Selection & Filtering
- GroupBy (basic functionality)
- Aggregations

**IO**

- CSV / Parquet / Arrow

**Performance**

- SIMD optimizations (Phase 2)
- Multi‚Äëthreaded Aggregations (Phase 2)

**SQL**

- Simple SQL parser (Phase 2)

---

## ü§ù Contributing

Contributions are welcome!

Short version:

1. Fork the repository
2. Create a feature branch
3. Run tests: `dotnet test`
4. Open a Pull Request

---

## üìÑ License

MIT License ‚Äî see `LICENSE`.

===== FILE: THIRD-PARTY-NOTICES.txt =====
LeichtFrame
Copyright (c) 2025 The LeichtFrame Authors
Licensed under the MIT License.

This project uses third-party libraries which are distributed under their own terms.

--------------------------------------------------------------------------------
Apache Arrow for .NET
Copyright 2016-2025 The Apache Software Foundation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
Parquet.Net
Copyright (c) 2017-2025 Parquet.Net developers

Licensed under the MIT License.
--------------------------------------------------------------------------------
===== FILE: docs/PROFILING.md =====
# LeichtFrame Profiling Guide

This guide explains how to profile CPU usage, memory allocations, and GC behavior for LeichtFrame. It serves as a reference for maintaining the high-performance standards of the library.

## üéØ Performance Baselines (Acceptance Criteria)

Any change to the Core engine must respect these baselines to ensure the "high-performance" promise is kept.

| Metric              | Scenario                       | Limit / Goal                                 |
| :------------------ | :----------------------------- | :------------------------------------------- |
| **Allocation**      | `IntColumn` Creation (1M rows) | **~0 Bytes** (Zero-Allocation via ArrayPool) |
| **Slicing**         | `Slice(start, length)`         | **< 10 ns** (O(1) / Zero-Copy)               |
| **Memory Overhead** | Overhead per Column            | **< 100 Bytes** (Class wrapper only)         |
| **NullBitmap**      | Set/Get Speed                  | **< 2x** of native `bool[]` time             |
| **Throughput**      | Random Access (Get/Set)        | **< 10 ns** per op (hot cache)               |

## üõ† Tools (Linux/macOS/Windows)

We use standard .NET global tools. Ensure you have them installed:

```bash
dotnet tool install --global dotnet-trace
dotnet tool install --global dotnet-counters
dotnet tool install --global dotnet-gcdump
```

---

## CPU Profiling (dotnet-trace)

Use `dotnet-trace` to identify "hot paths" (methods that consume the most CPU time) or blocking calls.

**How to run**

Use the helper script to run the benchmarks with tracing enabled:

```bash
./scripts/profile_cpu.sh
```

**Analyze**

The output file (`traces/cpu_trace.nettrace`) can be analyzed in two ways:

- **Visual Studio (Windows):** Open the file directly.
- **Speedscope (Cross-platform):**

  1. Convert the trace:

```bash
dotnet-trace convert --format speedscope traces/cpu_trace.nettrace
```

2. Upload the resulting `.speedscope.json` to [https://speedscope.app](https://speedscope.app).

## Real-time GC Monitoring (dotnet-counters)

Use `dotnet-counters` to see Garbage Collection generations and heap size in real-time. This is crucial to verify "Zero-Allocation" claims.

**How to run**

1. Start your application or benchmark loop.
2. Find the Process ID (PID) using `dotnet-counters ps`.
3. Run the monitor script:

```bash
./scripts/monitor_gc.sh <PID>
```

**Key Metrics to watch**

- **GC Heap Size (MB):** Should remain stable. Continuous growth indicates a memory leak.
- **Gen 0 GC Count:** Should be low/zero during data processing phases (thanks to ArrayPool).
- **Allocation Rate:** Should be near zero for Core operations.

## Memory Heap Snapshots (dotnet-gcdump)

Use `dotnet-gcdump` to find memory leaks (objects that are not collected) or to inspect the object graph.

**How to run**

```bash
./scripts/capture_dump.sh <PID>
```

**Analyze**

Open the resulting `.gcdump` file in Visual Studio or VS Code (using the **.NET Install Tool** extension). You can compare two dumps to see which objects survived between snapshots.

## üöë Troubleshooting ‚Äî Common Issues

- **High Gen 2 Collections:** This usually means large objects (>85KB) are being allocated frequently without pooling, or objects are living too long. Check ArrayPool usage.

- **Rising Heap Size:** If the heap grows indefinitely, check for `IDisposable` objects (Columns) that are not being disposed, preventing the ArrayPool from reclaiming arrays.

- **Slow Slicing:** Ensure you are using `ReadOnlyMemory<T>` or `Span<T>` and not copying data to new arrays.

### Quick tips

- Prefer pooling (ArrayPool) for large buffers.
- Use `ValueTask`/`ref struct` patterns where appropriate to avoid allocations.
- Add focused microbenchmarks (BenchmarkDotNet) for suspicious hot paths.
- When in doubt, capture a short `dotnet-trace` and inspect flame graphs in speedscope.

---

_Saved: docs/PROFILING.md_

===== FILE: scripts/generate_docs.sh =====
#!/bin/bash
set -e # Exits as soon as any command fails

echo "üöÄ [1/4] Building Solution (Release)..."
# Builds Core and IO, updates XMLs and DLLs
dotnet build -c Release --verbosity quiet

echo "üßπ [2/4] Cleaning & Preparing website directories..."
# Ensure target directories exist
mkdir -p website/docs/api
mkdir -p website/docs/guides

# Delete old API documentation (so deleted classes also disappear here)
rm -rf website/docs/api/*

echo "üìÇ [3/4] Copying manual documentation..."
# This is where the magic happens: We copy PROFILING.md into the website folder
if [ -f "docs/PROFILING.md" ]; then
    cp docs/PROFILING.md website/docs/guides/profiling.md
    echo "   -> Copied PROFILING.md to website/docs/guides/"
else
    echo "‚ö†Ô∏è Warning: docs/PROFILING.md not found!"
fi

echo "üìù [4/4] Generating API Reference (MdDocs)..."
# Generates the API documentation from the DLLs
dotnet tool run mddocs apireference \
  --assemblies "src/LeichtFrame.Core/bin/Release/net8.0/LeichtFrame.Core.dll" "src/LeichtFrame.IO/bin/Release/net8.0/LeichtFrame.IO.dll" \
  --outdir "website/docs/api"

echo "‚úÖ Documentation generation complete!"
===== FILE: src/LeichtFrame.Benchmarks/AggregationBenchmarks.cs =====
using BenchmarkDotNet.Attributes;
using LeichtFrame.Core;

namespace LeichtFrame.Benchmarks
{
    [MemoryDiagnoser]
    public class AggregationBenchmarks
    {
        [Params(1_000_000)]
        public int N;

        // LeichtFrame Objects
        private DataFrame _df = null!;

        // LINQ Objects (Poco class to simulate row)
        private List<SalesRecord> _list = null!;

        private record SalesRecord(int BranchId, int Amount);

        [GlobalSetup]
        public void Setup()
        {
            // 1. Setup LeichtFrame
            var schema = new DataFrameSchema(new[] {
                new ColumnDefinition("BranchId", typeof(int)),
                new ColumnDefinition("Amount", typeof(int))
            });
            _df = DataFrame.Create(schema, N);
            var colBranch = (IntColumn)_df["BranchId"];
            var colAmount = (IntColumn)_df["Amount"];

            // 2. Setup LINQ
            _list = new List<SalesRecord>(N);

            var rnd = new Random(42);
            for (int i = 0; i < N; i++)
            {
                int branch = rnd.Next(0, 100); // 100 Groups
                int amount = rnd.Next(1, 1000);

                colBranch.Append(branch);
                colAmount.Append(amount);

                _list.Add(new SalesRecord(branch, amount));
            }
        }

        [GlobalCleanup]
        public void Cleanup()
        {
            _df.Dispose();
        }

        // --- Scenario 1: Global Sum (Span vs LINQ) ---

        [Benchmark(Baseline = true)]
        public long Linq_Sum()
        {
            return _list.Sum(x => (long)x.Amount);
        }

        [Benchmark]
        public double LeichtFrame_Sum()
        {
            // Should be super fast because of Span optimization
            return _df.Sum("Amount");
        }

        // --- Scenario 2: GroupBy + Sum (Dictionary vs LINQ) ---

        [Benchmark]
        public Dictionary<int, long> Linq_GroupBy_Sum()
        {
            return _list.GroupBy(x => x.BranchId)
                        .ToDictionary(g => g.Key, g => g.Sum(x => (long)x.Amount));
        }

        [Benchmark]
        public DataFrame LeichtFrame_GroupBy_Sum()
        {
            // Creates GroupedDataFrame -> Aggregates -> New DataFrame
            return _df.GroupBy("BranchId").Sum("Amount");
        }
    }
}
===== FILE: src/LeichtFrame.Benchmarks/BattleRoyaleBenchmarks.cs =====
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Jobs;
using LeichtFrame.Core;
using MDA = Microsoft.Data.Analysis;

namespace LeichtFrame.Benchmarks
{
    public record DataItem(int Id, int Val);

    [SimpleJob(RuntimeMoniker.Net80)]
    [MemoryDiagnoser]
    public class BattleRoyaleBenchmarks
    {
        [Params(1_000_000)]
        public int N;

        // --- LINQ ---
        private List<int> _linqRawInts = null!;
        private List<DataItem> _linqObjs = null!;
        private List<DataItem> _linqObjsRight = null!;

        // --- LeichtFrame ---
        private LeichtFrame.Core.DataFrame _lfFrame = null!;
        private LeichtFrame.Core.DataFrame _lfFrameRight = null!;

        // --- Microsoft ---
        private MDA.DataFrame _mdaFrame = null!;
        private MDA.DataFrame _mdaFrameRight = null!;

        [GlobalSetup]
        public void Setup()
        {
            var rnd = new Random(42);
            var dataIds = new int[N];
            var dataVals = new int[N];

            for (int i = 0; i < N; i++)
            {
                dataIds[i] = i;
                dataVals[i] = rnd.Next(100);
            }

            // --- 1. LINQ Setup ---
            _linqRawInts = new List<int>(dataVals);
            _linqObjs = dataIds.Zip(dataVals, (id, val) => new DataItem(id, val)).ToList();
            _linqObjsRight = new List<DataItem>(_linqObjs);

            // --- 2. LeichtFrame Setup ---
            // Schema Links
            var schemaLeft = new DataFrameSchema(new[] {
                new ColumnDefinition("Id", typeof(int)),
                new ColumnDefinition("Val", typeof(int))
            });

            // Schema Rechts
            var schemaRight = new DataFrameSchema(new[] {
                new ColumnDefinition("Id", typeof(int)),
                new ColumnDefinition("Val_Right", typeof(int))
            });

            _lfFrame = LeichtFrame.Core.DataFrame.Create(schemaLeft, N);
            var lfId = (IntColumn)_lfFrame["Id"];
            var lfVal = (IntColumn)_lfFrame["Val"];

            _lfFrameRight = LeichtFrame.Core.DataFrame.Create(schemaRight, N);
            var lfIdR = (IntColumn)_lfFrameRight["Id"];
            var lfValR = (IntColumn)_lfFrameRight["Val_Right"];

            // Append
            for (int i = 0; i < N; i++)
            {
                lfId.Append(dataIds[i]);
                lfVal.Append(dataVals[i]);

                lfIdR.Append(dataIds[i]);
                lfValR.Append(dataVals[i]);
            }

            // --- 3. Microsoft Setup ---
            var mdaId = new MDA.PrimitiveDataFrameColumn<int>("Id", N);
            var mdaVal = new MDA.PrimitiveDataFrameColumn<int>("Val", N);
            for (int i = 0; i < N; i++) { mdaId[i] = dataIds[i]; mdaVal[i] = dataVals[i]; }
            _mdaFrame = new MDA.DataFrame(mdaId, mdaVal);

            var mdaIdR = new MDA.PrimitiveDataFrameColumn<int>("Id", N);
            var mdaValR = new MDA.PrimitiveDataFrameColumn<int>("Val", N);
            for (int i = 0; i < N; i++) { mdaIdR[i] = dataIds[i]; mdaValR[i] = dataVals[i]; }
            _mdaFrameRight = new MDA.DataFrame(mdaIdR, mdaValR);
        }

        [GlobalCleanup]
        public void Cleanup()
        {
            _lfFrame.Dispose();
            _lfFrameRight.Dispose();
        }

        // --- AGGREGATION ---
        [Benchmark(Description = "Sum (Agg)")]
        public double Agg_LeichtFrame() => _lfFrame.Sum("Val");

        [Benchmark(Baseline = true, Description = "Sum (LINQ List<int>)")]
        public long Agg_LINQ_Raw() => _linqRawInts.Sum(x => (long)x);

        [Benchmark(Description = "Sum (MS Data Analysis)")]
        public double Agg_Microsoft()
        {
            return Convert.ToDouble(_mdaFrame["Val"].Sum());
        }

        // --- FILTER ---
        [Benchmark(Description = "Filter (Where > 50)")]
        public object Filter_LeichtFrame() => _lfFrame.Where(row => row.Get<int>("Val") > 50);

        [Benchmark(Description = "Filter (LINQ Objects)")]
        public object Filter_LINQ_Obj() => _linqObjs.Where(x => x.Val > 50).ToList();

        [Benchmark(Description = "Filter (MS Data Analysis)")]
        public object Filter_Microsoft()
        {
            var col = _mdaFrame.Columns["Val"];
            var boolFilter = col.ElementwiseGreaterThan(50);
            return _mdaFrame.Filter(boolFilter);
        }

        // --- JOIN ---
        [Benchmark(Description = "Join (Inner on Id)")]
        public object Join_LeichtFrame()
        {
            return _lfFrame.Join(_lfFrameRight, "Id", JoinType.Inner);
        }

        [Benchmark(Description = "Join (LINQ Objects)")]
        public object Join_LINQ_Obj()
        {
            return _linqObjs.Join(
                _linqObjsRight,
                left => left.Id,
                right => right.Id,
                (left, right) => new { Left = left, Right = right }
            ).ToList();
        }

        [Benchmark(Description = "Join (MS Data Analysis)")]
        public object Join_Microsoft()
        {
            return _mdaFrame.Merge(_mdaFrameRight, new[] { "Id" }, new[] { "Id" });
        }
    }
}
===== FILE: src/LeichtFrame.Benchmarks/ColumnAllocationBenchmarks.cs =====
using BenchmarkDotNet.Attributes;
using LeichtFrame.Core;

namespace LeichtFrame.Benchmarks
{
    [MemoryDiagnoser] // Important: Measures RAM usage & GC
    [ShortRunJob]     // FFor faster testing during development (use "DefaultJob" in release)
    public class ColumnAllocationBenchmarks
    {
        [Params(100_000, 1_000_000)] // Test with 100k and 1M rows
        public int N;

        [Benchmark(Baseline = true)]
        public int[] NativeArrayAllocation()
        {
            // Standard .NET behavior: Always new heap memory
            return new int[N];
        }

        [Benchmark]
        public void LeichtFrame_IntColumn()
        {
            // Your code: Should use ArrayPool
            using var col = new IntColumn("Bench", N);
            // We simulate usage so the JIT doesn't optimize it away
            col.Append(42);
        }
    }
}
===== FILE: src/LeichtFrame.Benchmarks/FilterBenchmarks.cs =====
using BenchmarkDotNet.Attributes;
using LeichtFrame.Core;

namespace LeichtFrame.Benchmarks
{
    [MemoryDiagnoser]
    public class FilterBenchmarks
    {
        [Params(1_000_000)]
        public int N;

        private DataFrame _df = null!;
        private List<int> _list = null!;

        [GlobalSetup]
        public void Setup()
        {
            // 1. Setup LeichtFrame
            var schema = new DataFrameSchema(new[] { new ColumnDefinition("Val", typeof(int)) });
            _df = DataFrame.Create(schema, N);
            var col = (IntColumn)_df["Val"];

            // 2. Setup LINQ List
            _list = new List<int>(N);

            for (int i = 0; i < N; i++)
            {
                col.Append(i);
                _list.Add(i);
            }
        }

        [GlobalCleanup]
        public void Cleanup()
        {
            _df.Dispose();
        }

        // Baseline: Standard C# LINQ
        [Benchmark(Baseline = true)]
        public List<int> Linq_Where_ToList()
        {
            // Filter: All values > N/2
            return _list.Where(x => x > N / 2).ToList();
        }

        // Your candidate
        [Benchmark]
        public DataFrame LeichtFrame_Where()
        {
            // Same filter
            int threshold = N / 2;
            return _df.Where(row => row.Get<int>(0) > threshold);
        }
    }
}
===== FILE: src/LeichtFrame.Benchmarks/JoinBenchmarks.cs =====
using BenchmarkDotNet.Attributes;
using LeichtFrame.Core;

namespace LeichtFrame.Benchmarks
{
    [MemoryDiagnoser]
    public class JoinBenchmarks
    {
        [Params(100_000)] // We start with 100k, as joins are expensive (for 1M possibly adjust params)
        public int N;

        // LeichtFrame
        private DataFrame _dfLeft = null!;
        private DataFrame _dfRight = null!;

        // LINQ
        private List<RecordLeft> _listLeft = null!;
        private List<RecordRight> _listRight = null!;

        // POCOs f√ºr LINQ
        record RecordLeft(int Id, int ValueLeft);
        record RecordRight(int Id, int ValueRight);

        [GlobalSetup]
        public void Setup()
        {
            // 1. Setup LeichtFrame
            var schemaLeft = new DataFrameSchema(new[] { new ColumnDefinition("Id", typeof(int)), new ColumnDefinition("ValL", typeof(int)) });
            var schemaRight = new DataFrameSchema(new[] { new ColumnDefinition("Id", typeof(int)), new ColumnDefinition("ValR", typeof(int)) });

            _dfLeft = DataFrame.Create(schemaLeft, N);
            _dfRight = DataFrame.Create(schemaRight, N);

            var lId = (IntColumn)_dfLeft["Id"]; var lVal = (IntColumn)_dfLeft["ValL"];
            var rId = (IntColumn)_dfRight["Id"]; var rVal = (IntColumn)_dfRight["ValR"];

            // 2. Setup LINQ
            _listLeft = new List<RecordLeft>(N);
            _listRight = new List<RecordRight>(N);

            for (int i = 0; i < N; i++)
            {
                // 1:1 Match for maximum stress
                lId.Append(i); lVal.Append(i * 10);
                rId.Append(i); rVal.Append(i * 20);

                _listLeft.Add(new RecordLeft(i, i * 10));
                _listRight.Add(new RecordRight(i, i * 20));
            }
        }

        [GlobalCleanup]
        public void Cleanup()
        {
            _dfLeft.Dispose();
            _dfRight.Dispose();
        }

        [Benchmark(Baseline = true)]
        public int Linq_Join()
        {
            // Standard LINQ Hash Join
            var result = _listLeft.Join(_listRight,
                left => left.Id,
                right => right.Id,
                (left, right) => new { left.Id, left.ValueLeft, right.ValueRight })
                .ToList(); // Materialize!

            return result.Count;
        }

        [Benchmark]
        public DataFrame LeichtFrame_Join()
        {
            // Unser Hash Join
            return _dfLeft.Join(_dfRight, on: "Id", JoinType.Inner);
        }
    }
}
===== FILE: src/LeichtFrame.Benchmarks/LeichtFrame.Benchmarks.csproj =====
Ôªø<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsPackable>false</IsPackable>

    <GenerateDocumentationFile>false</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);CS1591</NoWarn>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="BenchmarkDotNet" Version="0.15.8" />
    <PackageReference Include="Microsoft.Data.Analysis" Version="0.23.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\LeichtFrame.Core\LeichtFrame.Core.csproj" />
  </ItemGroup>

</Project>

===== FILE: src/LeichtFrame.Benchmarks/NullHandlingBenchmarks.cs =====
using BenchmarkDotNet.Attributes;
using LeichtFrame.Core;

namespace LeichtFrame.Benchmarks
{
    [MemoryDiagnoser]
    public class NullHandlingBenchmarks
    {
        [Params(1_000_000)]
        public int N;

        private NullBitmap _bitmap = null!;
        private bool[] _boolArray = null!;

        [GlobalSetup]
        public void Setup()
        {
            _bitmap = new NullBitmap(N);
            _boolArray = new bool[N];
        }

        [GlobalCleanup]
        public void Cleanup()
        {
            _bitmap.Dispose();
        }

        [Benchmark(Baseline = true)]
        public void BoolArray_Set()
        {
            // Simulate access to every 100th position
            for (int i = 0; i < N; i += 100)
            {
                _boolArray[i] = true;
            }
        }

        [Benchmark]
        public void NullBitmap_Set()
        {
            for (int i = 0; i < N; i += 100)
            {
                _bitmap.SetNull(i);
            }
        }
    }
}
===== FILE: src/LeichtFrame.Benchmarks/Program.cs =====
Ôªøusing BenchmarkDotNet.Running;

namespace LeichtFrame.Benchmarks
{
    public class Program
    {
        public static void Main(string[] args)
        {
            // Executes all benchmarks in the assembly and provides a menu
            BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args);
        }
    }
}

===== FILE: src/LeichtFrame.Benchmarks/SlicingBenchmarks.cs =====
using BenchmarkDotNet.Attributes;
using LeichtFrame.Core;

namespace LeichtFrame.Benchmarks
{
    [MemoryDiagnoser]
    public class SlicingBenchmarks
    {
        private IntColumn _col = null!;

        [Params(1_000_000)]
        public int N;

        [GlobalSetup]
        public void Setup()
        {
            _col = new IntColumn("SliceBench", N);
            for (int i = 0; i < N; i++) _col.Append(i);
        }

        [GlobalCleanup]
        public void Cleanup()
        {
            _col.Dispose();
        }

        [Benchmark]
        public ReadOnlyMemory<int> CreateSlice()
        {
            // This here must be extremely fast (ns range)
            return _col.Slice(0, N / 2);
        }
    }
}
===== FILE: src/LeichtFrame.Benchmarks/StructureBenchmarks.cs =====
using BenchmarkDotNet.Attributes;
using LeichtFrame.Core;

namespace LeichtFrame.Benchmarks
{
    [MemoryDiagnoser]
    public class StructureBenchmarks
    {
        [Params(10_000, 1_000_000)] // Test small and large to prove O(1)
        public int N;

        private DataFrame _df = null!;

        [GlobalSetup]
        public void Setup()
        {
            // 1. Define schema
            var schema = new DataFrameSchema(new[] {
                new ColumnDefinition("Col1", typeof(int)),
                new ColumnDefinition("Col2", typeof(int)),
                new ColumnDefinition("Col3", typeof(int)),
                new ColumnDefinition("Col4", typeof(int)),
                new ColumnDefinition("Col5", typeof(int))
            });

            // 2. Create DataFrame
            _df = DataFrame.Create(schema, N);

            // 3. Fill ALL columns
            // So that all have length N and no "Length Mismatch" occurs.
            foreach (var col in _df.Columns)
            {
                var intCol = (IntColumn)col;
                for (int i = 0; i < N; i++)
                {
                    intCol.Append(i);
                }
            }
        }

        [GlobalCleanup]
        public void Cleanup()
        {
            _df.Dispose();
        }

        // Scenario: Column Access
        [Benchmark]
        public IColumn Indexer_ByName()
        {
            return _df["Col3"]; // Should be O(1) dictionary lookup
        }

        // Scenario: Projection (Select)
        [Benchmark]
        public DataFrame Select_TwoColumns()
        {
            // Should be extremely fast and only copy metadata (Shallow Copy)
            return _df.Select("Col1", "Col5");
        }

        // Scenario: Slicing (Head)
        [Benchmark]
        public DataFrame Head_100()
        {
            // Should create SlicedColumn wrapper, no data copying
            return _df.Head(100);
        }

        // Scenario: Slicing (Middle)
        [Benchmark]
        public DataFrame Slice_Middle()
        {
            // In the middle
            return _df.Slice(N / 2, 1000);
        }
    }
}
===== FILE: src/LeichtFrame.Core/Columns/BoolColumn.cs =====
using System.Buffers;
using System.Runtime.CompilerServices;

namespace LeichtFrame.Core
{
    /// <summary>
    /// A high-performance column for storing boolean values.
    /// Uses internal bit-packing (1 bit per boolean) to reduce memory usage by 87.5% compared to bool[].
    /// </summary>
    public class BoolColumn : Column<bool>, IDisposable
    {
        private byte[] _data; // 8 bools per byte
        private NullBitmap? _nulls;
        private int _length;

        /// <summary>
        /// Initializes a new instance of the <see cref="BoolColumn"/> class.
        /// </summary>
        /// <param name="name">The name of the column.</param>
        /// <param name="capacity">The initial capacity (number of rows).</param>
        /// <param name="isNullable">Whether the column supports null values.</param>
        public BoolColumn(string name, int capacity = 16, bool isNullable = false)
            : base(name, isNullable)
        {
            _length = 0;
            // Calculate required bytes: (capacity + 7) / 8
            int byteCount = (capacity + 7) >> 3;
            _data = ArrayPool<byte>.Shared.Rent(byteCount);
            Array.Clear(_data, 0, byteCount);

            if (isNullable)
            {
                _nulls = new NullBitmap(capacity);
            }
        }

        /// <inheritdoc />
        public override int Length => _length;

        /// <summary>
        /// Gets the raw values as memory. 
        /// <para>
        /// <b>Not Supported for BoolColumn:</b> Because booleans are bit-packed, they cannot be represented as a contiguous <see cref="ReadOnlyMemory{Boolean}"/>.
        /// Use <see cref="Get(int)"/> or specialized bulk operations instead.
        /// </para>
        /// </summary>
        /// <exception cref="NotSupportedException">Always thrown.</exception>
        public override ReadOnlyMemory<bool> Values => throw new NotSupportedException(
            "BoolColumn uses bit-packed storage. Cannot return ReadOnlyMemory<bool>. Use GetValue or dedicated bulk methods.");

        // --- Core Data Access ---

        /// <inheritdoc />
        public override bool Get(int index)
        {
            CheckBounds(index);
            return (_data[index >> 3] & (1 << (index & 7))) != 0;
        }

        /// <inheritdoc />
        public override void SetValue(int index, bool value)
        {
            CheckBounds(index);
            SetBit(index, value);
            _nulls?.SetNotNull(index);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void SetBit(int index, bool value)
        {
            int byteIndex = index >> 3;
            int bitMask = 1 << (index & 7);

            if (value)
                _data[byteIndex] |= (byte)bitMask;
            else
                _data[byteIndex] &= (byte)~bitMask;
        }

        /// <inheritdoc />
        public override void Append(bool value)
        {
            EnsureCapacity(_length + 1);
            SetBit(_length, value);
            _nulls?.SetNotNull(_length);
            _length++;
        }

        /// <summary>
        /// Appends a nullable boolean to the column.
        /// </summary>
        /// <param name="value">The value to append, or null.</param>
        public void Append(bool? value)
        {
            EnsureCapacity(_length + 1);
            if (value.HasValue)
            {
                SetBit(_length, value.Value);
                _nulls?.SetNotNull(_length);
            }
            else
            {
                if (_nulls == null) throw new InvalidOperationException("Cannot append null to non-nullable column.");
                SetBit(_length, false);
                _nulls.SetNull(_length);
            }
            _length++;
        }

        // --- Null Handling ---

        /// <inheritdoc />
        public override bool IsNull(int index)
        {
            CheckBounds(index);
            return _nulls != null && _nulls.IsNull(index);
        }

        /// <inheritdoc />
        public override void SetNull(int index)
        {
            CheckBounds(index);
            if (_nulls == null) throw new InvalidOperationException("Cannot set null on non-nullable column.");
            SetBit(index, false);
            _nulls.SetNull(index);
        }

        /// <summary>
        /// Marks the value at the specified index as not null.
        /// </summary>
        public override void SetNotNull(int index)
        {
            CheckBounds(index);
            _nulls?.SetNotNull(index);
        }

        // --- Bulk Operations ---

        /// <summary>
        /// Checks if any value in the column is true (optimized bit-scan).
        /// </summary>
        public bool AnyTrue()
        {
            if (_nulls == null)
            {
                int fullBytes = _length >> 3;
                for (int i = 0; i < fullBytes; i++)
                {
                    if (_data[i] != 0) return true;
                }
                for (int i = fullBytes * 8; i < _length; i++)
                {
                    if (Get(i)) return true;
                }
                return false;
            }
            else
            {
                for (int i = 0; i < _length; i++)
                {
                    if (!IsNull(i) && Get(i)) return true;
                }
                return false;
            }
        }

        /// <summary>
        /// Checks if all values in the column are true (optimized bit-scan).
        /// </summary>
        public bool AllTrue()
        {
            if (_length == 0) return true;

            if (_nulls == null)
            {
                int fullBytes = _length >> 3;
                for (int i = 0; i < fullBytes; i++)
                {
                    if (_data[i] != 0xFF) return false;
                }
                for (int i = fullBytes * 8; i < _length; i++)
                {
                    if (!Get(i)) return false;
                }
                return true;
            }
            else
            {
                for (int i = 0; i < _length; i++)
                {
                    if (!IsNull(i) && !Get(i)) return false;
                }
                return true;
            }
        }

        // --- Memory ---

        /// <inheritdoc />
        public override void EnsureCapacity(int minCapacity)
        {
            int currentByteCap = _data.Length;
            int requiredByteCap = (minCapacity + 7) >> 3;

            if (currentByteCap >= requiredByteCap) return;

            int newByteCap = Math.Max(currentByteCap * 2, requiredByteCap);

            var newBuffer = ArrayPool<byte>.Shared.Rent(newByteCap);

            Array.Copy(_data, newBuffer, (Length + 7) >> 3);
            Array.Clear(newBuffer, (Length + 7) >> 3, newByteCap - ((Length + 7) >> 3));

            ArrayPool<byte>.Shared.Return(_data);
            _data = newBuffer;

            _nulls?.Resize(minCapacity);
        }

        private void CheckBounds(int index)
        {
            if ((uint)index >= (uint)_length) throw new IndexOutOfRangeException();
        }

        /// <inheritdoc />
        public override IColumn CloneSubset(IReadOnlyList<int> indices)
        {
            var newCol = new BoolColumn(Name, indices.Count, IsNullable);

            for (int i = 0; i < indices.Count; i++)
            {
                int sourceIndex = indices[i];
                if (IsNullable && IsNull(sourceIndex))
                {
                    newCol.Append(null);
                }
                else
                {
                    newCol.Append(Get(sourceIndex));
                }
            }
            return newCol;
        }

        /// <inheritdoc />
        public void Dispose()
        {
            if (_data != null)
            {
                ArrayPool<byte>.Shared.Return(_data);
                _data = null!;
            }
            _nulls?.Dispose();
            _nulls = null;
        }
    }
}
===== FILE: src/LeichtFrame.Core/Columns/Column.cs =====
Ôªønamespace LeichtFrame.Core;

/// <summary>
/// Non-generic base class for all columns. 
/// Allows storing columns of different types in a single collection.
/// </summary>
public abstract class Column : IColumn
{
    /// <inheritdoc />
    public string Name { get; }

    /// <inheritdoc />
    public Type DataType { get; }

    /// <inheritdoc />
    public bool IsNullable { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="Column"/> class.
    /// </summary>
    /// <param name="name">The unique name of the column.</param>
    /// <param name="dataType">The CLR type of the data stored.</param>
    /// <param name="isNullable">Whether the column allows null values.</param>
    /// <exception cref="ArgumentException">Thrown if name is null or whitespace.</exception>
    /// <exception cref="ArgumentNullException">Thrown if dataType is null.</exception>
    protected Column(string name, Type dataType, bool isNullable)
    {
        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Column name cannot be null or empty.", nameof(name));

        Name = name;
        DataType = dataType ?? throw new ArgumentNullException(nameof(dataType));
        IsNullable = isNullable;
    }

    /// <inheritdoc />
    public abstract int Length { get; }

    /// <inheritdoc />
    public abstract void EnsureCapacity(int capacity);

    /// <inheritdoc />
    public abstract object? GetValue(int index);

    /// <inheritdoc />
    public abstract void AppendObject(object? value);

    /// <inheritdoc />
    public abstract IColumn CloneSubset(IReadOnlyList<int> indices);

    /// <inheritdoc />
    public abstract bool IsNull(int index);

    /// <inheritdoc />
    public abstract void SetNull(int index);
}
===== FILE: src/LeichtFrame.Core/Columns/ColumnFactory.cs =====
namespace LeichtFrame.Core
{
    /// <summary>
    /// Factory class to create concrete column instances based on runtime types.
    /// Acts as the central registry for supported column types.
    /// </summary>
    public static class ColumnFactory
    {
        /// <summary>
        /// Creates a concrete column instance (e.g. <see cref="IntColumn"/>) based on the provided CLR type.
        /// </summary>
        /// <param name="name">The name of the column.</param>
        /// <param name="type">The data type (e.g. typeof(int)). Supported: int, double, bool, string, DateTime.</param>
        /// <param name="capacity">The initial capacity (number of rows) to allocate.</param>
        /// <param name="isNullable">Whether the column should support null values.</param>
        /// <returns>An <see cref="IColumn"/> instance containing the specific implementation.</returns>
        /// <exception cref="NotSupportedException">Thrown if the provided type is not supported by LeichtFrame.</exception>
        public static IColumn Create(string name, Type type, int capacity = 16, bool isNullable = false)
        {
            if (type == typeof(int))
                return new IntColumn(name, capacity, isNullable);

            if (type == typeof(double))
                return new DoubleColumn(name, capacity, isNullable);

            if (type == typeof(bool))
                return new BoolColumn(name, capacity, isNullable);

            if (type == typeof(string))
                return new StringColumn(name, capacity, isNullable);

            if (type == typeof(DateTime))
                return new DateTimeColumn(name, capacity, isNullable);

            throw new NotSupportedException($"Type {type.Name} is not supported yet.");
        }

        /// <summary>
        /// Generic convenience overload to create a strongly-typed column.
        /// </summary>
        /// <typeparam name="T">The data type of the column.</typeparam>
        /// <param name="name">The name of the column.</param>
        /// <param name="capacity">The initial capacity to allocate.</param>
        /// <param name="isNullable">Whether the column should support null values.</param>
        /// <returns>A typed <see cref="IColumn{T}"/> instance.</returns>
        public static IColumn<T> Create<T>(string name, int capacity = 16, bool isNullable = false)
        {
            return (IColumn<T>)Create(name, typeof(T), capacity, isNullable);
        }
    }
}
===== FILE: src/LeichtFrame.Core/Columns/ColumnT.cs =====
using System.Globalization;

namespace LeichtFrame.Core;

/// <summary>
/// Typed base class for columns storing specific data types (int, double, string, etc.).
/// </summary>
/// <typeparam name="T">The type of data stored in this column.</typeparam>
public abstract class Column<T> : Column, IColumn<T>
{
    /// <summary>
    /// Initializes a new instance of the <see cref="Column{T}"/> class.
    /// </summary>
    /// <param name="name">The name of the column.</param>
    /// <param name="isNullable">Whether the column supports null values.</param>
    protected Column(string name, bool isNullable = false) : base(name, typeof(T), isNullable)
    {
    }

    /// <summary>
    /// Gets the underlying memory storage of the column.
    /// </summary>
    public abstract ReadOnlyMemory<T> Values { get; }

    /// <summary>
    /// Gets the strongly-typed value at the specified index.
    /// </summary>
    /// <param name="index">The zero-based row index.</param>
    /// <returns>The value of type T.</returns>
    public abstract T Get(int index);

    /// <inheritdoc />
    public abstract void SetValue(int index, T value);

    // --- Interface Implementations ---

    T IColumn<T>.GetValue(int index) => Get(index);

    /// <inheritdoc />
    public override object? GetValue(int index)
    {
        if (IsNullable && IsNull(index)) return null;
        return Get(index);
    }

    // --- Appending ---

    /// <inheritdoc />
    public abstract void Append(T value);

    // WICHTIG: Hier muss 'override' stehen, da es in 'Column' abstract ist.
    /// <inheritdoc />
    public override void AppendObject(object? value)
    {
        if (value is T typedVal)
        {
            Append(typedVal);
        }
        else if (value is null)
        {
            if (!IsNullable)
                throw new ArgumentException($"Cannot append null to non-nullable column '{Name}'.");

            Append(default!);
            SetNull(Length - 1);
        }
        else
        {
            try
            {
                var converted = (T)Convert.ChangeType(value, typeof(T), CultureInfo.InvariantCulture);
                Append(converted);
            }
            catch
            {
                throw new ArgumentException($"Cannot convert '{value}' to {typeof(T).Name}");
            }
        }
    }

    // --- Null Handling ---

    /// <inheritdoc />
    public abstract override bool IsNull(int index);

    /// <inheritdoc />
    public abstract override void SetNull(int index);

    /// <summary>
    /// Marks the value at the specified index as not null.
    /// </summary>
    /// <param name="index">The zero-based row index.</param>
    public abstract void SetNotNull(int index);

    // --- Slicing ---

    /// <inheritdoc />
    public virtual ReadOnlyMemory<T> Slice(int start, int length)
    {
        if ((uint)start > (uint)Length || (uint)length > (uint)(Length - start))
        {
            throw new ArgumentOutOfRangeException(nameof(start),
                $"Slice range {start}..{start + length} is out of bounds (Length: {Length}).");
        }

        return Values.Slice(start, length);
    }

    /// <inheritdoc />
    public virtual ReadOnlySpan<T> AsSpan() => Values.Span;
}
===== FILE: src/LeichtFrame.Core/Columns/DateTimeColumn.cs =====
using System.Buffers;

namespace LeichtFrame.Core
{
    /// <summary>
    /// A high-performance column for storing <see cref="DateTime"/> values.
    /// Uses pooled arrays for zero-allocation data management.
    /// </summary>
    public class DateTimeColumn : Column<DateTime>, IDisposable
    {
        private DateTime[] _data;
        private NullBitmap? _nulls;
        private int _length;

        /// <summary>
        /// Initializes a new instance of the <see cref="DateTimeColumn"/> class.
        /// </summary>
        /// <param name="name">The name of the column.</param>
        /// <param name="capacity">The initial capacity (number of rows).</param>
        /// <param name="isNullable">Whether the column supports null values.</param>
        public DateTimeColumn(string name, int capacity = 16, bool isNullable = false)
            : base(name, isNullable)
        {
            _length = 0;
            _data = ArrayPool<DateTime>.Shared.Rent(capacity);

            if (isNullable)
            {
                _nulls = new NullBitmap(capacity);
            }
        }

        /// <inheritdoc />
        public override int Length => _length;

        /// <inheritdoc />
        public override ReadOnlyMemory<DateTime> Values => new ReadOnlyMemory<DateTime>(_data, 0, _length);

        // --- Core Access ---

        /// <inheritdoc />
        public override DateTime Get(int index)
        {
            CheckBounds(index);
            return _data[index];
        }

        /// <inheritdoc />
        public override void SetValue(int index, DateTime value)
        {
            CheckBounds(index);
            _data[index] = value;
            _nulls?.SetNotNull(index);
        }

        /// <inheritdoc />
        public override void Append(DateTime value)
        {
            EnsureCapacity(_length + 1);
            _data[_length] = value;
            _nulls?.SetNotNull(_length);
            _length++;
        }

        /// <summary>
        /// Appends a nullable DateTime value.
        /// </summary>
        /// <param name="value">The value to append, or null.</param>
        /// <exception cref="InvalidOperationException">Thrown if null is passed to a non-nullable column.</exception>
        public void Append(DateTime? value)
        {
            EnsureCapacity(_length + 1);
            if (value.HasValue)
            {
                _data[_length] = value.Value;
                _nulls?.SetNotNull(_length);
            }
            else
            {
                if (_nulls == null)
                    throw new InvalidOperationException("Cannot append null to non-nullable column.");

                _data[_length] = default;
                _nulls.SetNull(_length);
            }
            _length++;
        }

        // --- Null Handling ---

        /// <inheritdoc />
        public override bool IsNull(int index)
        {
            CheckBounds(index);
            return _nulls != null && _nulls.IsNull(index);
        }

        /// <inheritdoc />
        public override void SetNull(int index)
        {
            CheckBounds(index);
            if (_nulls == null)
                throw new InvalidOperationException("Cannot set null on non-nullable column.");

            _data[index] = default;
            _nulls.SetNull(index);
        }

        /// <inheritdoc />
        public override void SetNotNull(int index)
        {
            CheckBounds(index);
            _nulls?.SetNotNull(index);
        }

        // --- Memory Management ---

        /// <inheritdoc />
        public override void EnsureCapacity(int minCapacity)
        {
            if (_data.Length >= minCapacity) return;

            int newCapacity = Math.Max(_data.Length * 2, minCapacity);

            var newBuffer = ArrayPool<DateTime>.Shared.Rent(newCapacity);
            Array.Copy(_data, newBuffer, _length);

            ArrayPool<DateTime>.Shared.Return(_data);
            _data = newBuffer;

            _nulls?.Resize(newCapacity);
        }

        private void CheckBounds(int index)
        {
            if ((uint)index >= (uint)_length)
                throw new IndexOutOfRangeException($"Index {index} is out of range.");
        }

        /// <inheritdoc />
        public override IColumn CloneSubset(IReadOnlyList<int> indices)
        {
            var newCol = new DateTimeColumn(Name, indices.Count, IsNullable);

            for (int i = 0; i < indices.Count; i++)
            {
                int sourceIndex = indices[i];
                if (IsNullable && IsNull(sourceIndex))
                {
                    newCol.Append(null);
                }
                else
                {
                    newCol.Append(Get(sourceIndex));
                }
            }
            return newCol;
        }

        /// <inheritdoc />
        public void Dispose()
        {
            if (_data != null)
            {
                ArrayPool<DateTime>.Shared.Return(_data);
                _data = null!;
            }
            _nulls?.Dispose();
            _nulls = null;
        }
    }
}
===== FILE: src/LeichtFrame.Core/Columns/DoubleColumn.cs =====
using System.Buffers;

namespace LeichtFrame.Core
{
    /// <summary>
    /// A high-performance column for storing <see cref="double"/> values.
    /// Supports optimized statistical operations like Sum, Min, and Max using contiguous memory.
    /// </summary>
    public class DoubleColumn : Column<double>, IDisposable
    {
        private double[] _data;
        private NullBitmap? _nulls;
        private int _length;

        /// <summary>
        /// Initializes a new instance of the <see cref="DoubleColumn"/> class.
        /// </summary>
        /// <param name="name">The name of the column.</param>
        /// <param name="capacity">The initial capacity (number of rows).</param>
        /// <param name="isNullable">Whether the column supports null values.</param>
        public DoubleColumn(string name, int capacity = 16, bool isNullable = false)
            : base(name, isNullable)
        {
            _length = 0;
            _data = ArrayPool<double>.Shared.Rent(capacity);
            if (isNullable) _nulls = new NullBitmap(capacity);
        }

        /// <inheritdoc />
        public override int Length => _length;

        /// <inheritdoc />
        public override ReadOnlyMemory<double> Values => new ReadOnlyMemory<double>(_data, 0, _length);

        // --- Core Data Access ---

        /// <inheritdoc />
        public override double Get(int index)
        {
            CheckBounds(index);
            return _data[index];
        }

        /// <inheritdoc />
        public override void SetValue(int index, double value)
        {
            CheckBounds(index);
            _data[index] = value;
            _nulls?.SetNotNull(index);
        }

        /// <inheritdoc />
        public override void Append(double value)
        {
            EnsureCapacity(_length + 1);
            _data[_length] = value;
            _nulls?.SetNotNull(_length);
            _length++;
        }

        /// <summary>
        /// Appends a nullable double value to the column.
        /// </summary>
        /// <param name="value">The value to append, or null.</param>
        /// <exception cref="InvalidOperationException">Thrown if null is passed to a non-nullable column.</exception>
        public void Append(double? value)
        {
            EnsureCapacity(_length + 1);
            if (value.HasValue)
            {
                _data[_length] = value.Value;
                _nulls?.SetNotNull(_length);
            }
            else
            {
                if (_nulls == null) throw new InvalidOperationException("Cannot append null to non-nullable column.");
                _data[_length] = double.NaN;
                _nulls.SetNull(_length);
            }
            _length++;
        }

        // --- Null Handling ---

        /// <inheritdoc />
        public override bool IsNull(int index)
        {
            CheckBounds(index);
            return _nulls != null && _nulls.IsNull(index);
        }

        /// <inheritdoc />
        public override void SetNull(int index)
        {
            CheckBounds(index);
            if (_nulls == null) throw new InvalidOperationException("Cannot set null on non-nullable column.");
            _data[index] = double.NaN;
            _nulls.SetNull(index);
        }

        /// <inheritdoc />
        public override void SetNotNull(int index)
        {
            CheckBounds(index);
            _nulls?.SetNotNull(index);
        }

        // --- Statistical Helpers ---

        /// <summary>
        /// Calculates the sum of all non-null values in the column.
        /// </summary>
        /// <returns>The sum of values.</returns>
        public double Sum()
        {
            double sum = 0;
            var span = Values.Span;

            if (_nulls == null)
            {
                for (int i = 0; i < _length; i++) sum += span[i];
            }
            else
            {
                for (int i = 0; i < _length; i++)
                {
                    if (!_nulls.IsNull(i)) sum += span[i];
                }
            }
            return sum;
        }

        /// <summary>
        /// Finds the minimum value in the column. Ignores null values.
        /// Returns 0 if the column is empty or contains only nulls.
        /// </summary>
        public double Min()
        {
            if (_length == 0) return 0;
            double min = double.MaxValue;
            bool hasValue = false;
            var span = Values.Span;

            for (int i = 0; i < _length; i++)
            {
                if (!IsNull(i))
                {
                    double val = span[i];
                    if (val < min) min = val;
                    hasValue = true;
                }
            }
            return hasValue ? min : 0;
        }

        /// <summary>
        /// Finds the maximum value in the column. Ignores null values.
        /// Returns 0 if the column is empty or contains only nulls.
        /// </summary>
        public double Max()
        {
            if (_length == 0) return 0;
            double max = double.MinValue;
            bool hasValue = false;
            var span = Values.Span;

            for (int i = 0; i < _length; i++)
            {
                if (!IsNull(i))
                {
                    double val = span[i];
                    if (val > max) max = val;
                    hasValue = true;
                }
            }
            return hasValue ? max : 0;
        }

        // --- Memory ---

        /// <inheritdoc />
        public override void EnsureCapacity(int minCapacity)
        {
            if (_data.Length >= minCapacity) return;
            int newCapacity = Math.Max(_data.Length * 2, minCapacity);

            var newBuffer = ArrayPool<double>.Shared.Rent(newCapacity);
            Array.Copy(_data, newBuffer, _length);
            ArrayPool<double>.Shared.Return(_data);
            _data = newBuffer;

            _nulls?.Resize(newCapacity);
        }

        private void CheckBounds(int index)
        {
            if ((uint)index >= (uint)_length) throw new IndexOutOfRangeException();
        }

        /// <inheritdoc />
        public override IColumn CloneSubset(IReadOnlyList<int> indices)
        {
            var newCol = new DoubleColumn(Name, indices.Count, IsNullable);

            for (int i = 0; i < indices.Count; i++)
            {
                int sourceIndex = indices[i];
                if (IsNullable && IsNull(sourceIndex))
                {
                    newCol.Append(null);
                }
                else
                {
                    newCol.Append(Get(sourceIndex));
                }
            }
            return newCol;
        }

        /// <inheritdoc />
        public void Dispose()
        {
            if (_data != null)
            {
                ArrayPool<double>.Shared.Return(_data);
                _data = null!;
            }
            _nulls?.Dispose();
            _nulls = null;
        }
    }
}
===== FILE: src/LeichtFrame.Core/Columns/IColumn.cs =====
namespace LeichtFrame.Core
{
    /// <summary>
    /// Represents a generic column in a DataFrame containing metadata and operations.
    /// </summary>
    public interface IColumn
    {
        /// <summary>
        /// Gets the unique name of the column.
        /// </summary>
        string Name { get; }

        /// <summary>
        /// Gets the CLR type of the data stored in this column.
        /// </summary>
        Type DataType { get; }

        /// <summary>
        /// Gets the number of rows in this column.
        /// </summary>
        int Length { get; }

        /// <summary>
        /// Indicates whether the column supports null values.
        /// </summary>
        bool IsNullable { get; }

        /// <summary>
        /// Ensures the column has space for at least the specified number of elements.
        /// If the capacity is increased, the underlying buffer is swapped.
        /// <para>
        /// <strong>SAFETY WARNING:</strong> Because this library uses array pooling, 
        /// calling this method may return the old buffer to the pool.
        /// Existing Spans pointing to the old buffer will become invalid.
        /// </para>
        /// </summary>
        /// <param name="capacity">The minimum required capacity.</param>
        void EnsureCapacity(int capacity);

        /// <summary>
        /// Gets the value at the specified index as an object (boxed).
        /// For high performance, use the typed interface <see cref="IColumn{T}"/>.
        /// </summary>
        /// <param name="index">The zero-based row index.</param>
        /// <returns>The value at the index, or null.</returns>
        object? GetValue(int index);

        /// <summary>
        /// Checks if the value at the specified index is null.
        /// </summary>
        bool IsNull(int index);

        /// <summary>
        /// Sets the value at the specified index to null.
        /// </summary>
        void SetNull(int index);

        /// <summary>
        /// Appends an untyped value to the end of the column.
        /// </summary>
        void AppendObject(object? value);

        /// <summary>
        /// Creates a deep copy of the column containing only the rows at the specified indices.
        /// </summary>
        /// <param name="indices">The list of row indices to copy.</param>
        /// <returns>A new column containing the subset of data.</returns>
        IColumn CloneSubset(IReadOnlyList<int> indices);
    }

    /// <summary>
    /// Typed interface for high-performance, zero-boxing data access.
    /// </summary>
    /// <typeparam name="T">The type of data stored in the column.</typeparam>
    public interface IColumn<T> : IColumn
    {
        /// <summary>
        /// Gets the strongly-typed value at the specified index.
        /// </summary>
        new T GetValue(int index);

        /// <summary>
        /// Sets the strongly-typed value at the specified index.
        /// </summary>
        void SetValue(int index, T value);


        /// <summary>
        /// Appends a strongly-typed value to the end of the column.
        /// </summary>
        void Append(T value);

        /// <summary>
        /// Returns a zero-copy view of the column data as a Memory region.
        /// </summary>
        ReadOnlyMemory<T> Slice(int start, int length);

        /// <summary>
        /// Returns the underlying data as a ReadOnlySpan for high-performance processing.
        /// </summary>
        ReadOnlySpan<T> AsSpan();
    }
}
===== FILE: src/LeichtFrame.Core/Columns/IntColumn.cs =====
using System.Buffers;

namespace LeichtFrame.Core
{
    /// <summary>
    /// A high-performance column for storing <see cref="int"/> values.
    /// Uses pooled arrays for zero-allocation data management.
    /// </summary>
    public class IntColumn : Column<int>, IDisposable
    {
        private int[] _data;
        private NullBitmap? _nulls;
        private int _length;

        /// <summary>
        /// Initializes a new instance of the <see cref="IntColumn"/> class.
        /// </summary>
        /// <param name="name">The name of the column.</param>
        /// <param name="capacity">The initial capacity (number of rows).</param>
        /// <param name="isNullable">Whether the column supports null values.</param>
        public IntColumn(string name, int capacity = 16, bool isNullable = false)
            : base(name, isNullable)
        {
            _length = 0;
            _data = ArrayPool<int>.Shared.Rent(capacity);

            if (isNullable)
            {
                _nulls = new NullBitmap(capacity);
            }
        }

        /// <inheritdoc />
        public override int Length => _length;

        /// <inheritdoc />
        public override ReadOnlyMemory<int> Values => new ReadOnlyMemory<int>(_data, 0, _length);

        // --- Core Get/Set ---

        /// <inheritdoc />
        public override int Get(int index)
        {
            CheckBounds(index);
            return _data[index];
        }

        /// <inheritdoc />
        public override void SetValue(int index, int value)
        {
            CheckBounds(index);
            _data[index] = value;
            _nulls?.SetNotNull(index);
        }

        // --- Append ---

        /// <inheritdoc />
        public override void Append(int value)
        {
            EnsureCapacity(_length + 1);
            _data[_length] = value;
            _nulls?.SetNotNull(_length);
            _length++;
        }

        /// <summary>
        /// Appends a nullable integer value to the column.
        /// </summary>
        /// <param name="value">The value to append, or null.</param>
        /// <exception cref="InvalidOperationException">Thrown if null is passed to a non-nullable column.</exception>
        public void Append(int? value)
        {
            EnsureCapacity(_length + 1);

            if (value.HasValue)
            {
                _data[_length] = value.Value;
                _nulls?.SetNotNull(_length);
            }
            else
            {
                if (_nulls == null)
                    throw new InvalidOperationException("Cannot append null to a non-nullable column.");

                _data[_length] = default;
                _nulls.SetNull(_length);
            }
            _length++;
        }

        // --- Null Handling ---

        /// <inheritdoc />
        public override bool IsNull(int index)
        {
            CheckBounds(index);
            return _nulls != null && _nulls.IsNull(index);
        }

        /// <inheritdoc />
        public override void SetNull(int index)
        {
            CheckBounds(index);
            if (_nulls == null)
                throw new InvalidOperationException("Cannot set null on a non-nullable column.");

            _data[index] = default;
            _nulls.SetNull(index);
        }

        /// <inheritdoc />
        public override void SetNotNull(int index)
        {
            CheckBounds(index);
            _nulls?.SetNotNull(index);
        }

        // --- Memory Management ---

        /// <inheritdoc />
        public override void EnsureCapacity(int minCapacity)
        {
            if (_data.Length >= minCapacity) return;

            int newCapacity = Math.Max(_data.Length * 2, minCapacity);

            var newBuffer = ArrayPool<int>.Shared.Rent(newCapacity);
            Array.Copy(_data, newBuffer, _length);
            ArrayPool<int>.Shared.Return(_data);
            _data = newBuffer;

            _nulls?.Resize(newCapacity);
        }

        private void CheckBounds(int index)
        {
            if ((uint)index >= (uint)_length)
                throw new IndexOutOfRangeException($"Index {index} is out of range (Length: {_length})");
        }

        /// <inheritdoc />
        public override IColumn CloneSubset(IReadOnlyList<int> indices)
        {
            var newCol = new IntColumn(Name, indices.Count, IsNullable);

            for (int i = 0; i < indices.Count; i++)
            {
                int sourceIndex = indices[i];
                if (IsNullable && IsNull(sourceIndex))
                {
                    newCol.Append(null);
                }
                else
                {
                    newCol.Append(Get(sourceIndex));
                }
            }
            return newCol;
        }

        /// <inheritdoc />
        public void Dispose()
        {
            if (_data != null)
            {
                ArrayPool<int>.Shared.Return(_data);
                _data = null!;
            }

            _nulls?.Dispose();
            _nulls = null;
        }
    }
}
===== FILE: src/LeichtFrame.Core/Columns/SlicedColumn.cs =====
using System;
using System.Collections.Generic;

namespace LeichtFrame.Core
{
    /// <summary>
    /// A zero-copy view over a subset of another column.
    /// Delegates calls to the source column with an index offset without allocating new memory for data.
    /// </summary>
    /// <typeparam name="T">The type of data stored in the column.</typeparam>
    public class SlicedColumn<T> : IColumn<T>, IDisposable
    {
        private readonly IColumn<T> _source;
        private readonly int _offset;
        private readonly int _length;

        /// <summary>
        /// Initializes a new instance of the <see cref="SlicedColumn{T}"/> class.
        /// </summary>
        /// <param name="source">The underlying source column.</param>
        /// <param name="offset">The zero-based starting index in the source column.</param>
        /// <param name="length">The number of rows in the slice.</param>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if offset or length are negative.</exception>
        /// <exception cref="ArgumentException">Thrown if the slice range exceeds the source column bounds.</exception>
        public SlicedColumn(IColumn<T> source, int offset, int length)
        {
            if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
            if (length < 0) throw new ArgumentOutOfRangeException(nameof(length));

            if (offset + length > source.Length)
                throw new ArgumentException($"Slice range ({offset}..{offset + length}) exceeds source column bounds (Length: {source.Length}).");

            _source = source;
            _offset = offset;
            _length = length;
        }

        /// <inheritdoc />
        public string Name => _source.Name;

        /// <inheritdoc />
        public Type DataType => _source.DataType;

        /// <inheritdoc />
        public int Length => _length;

        /// <inheritdoc />
        public bool IsNullable => _source.IsNullable;

        /// <inheritdoc />
        public ReadOnlyMemory<T> Values => _source.Slice(_offset, _length);

        /// <inheritdoc />
        public ReadOnlySpan<T> AsSpan() => Values.Span;

        // --- Data Access ---

        /// <inheritdoc />
        public T Get(int index)
        {
            CheckBounds(index);
            return _source.GetValue(index + _offset);
        }

        // Interface Implementation
        T IColumn<T>.GetValue(int index) => Get(index);

        /// <inheritdoc />
        public object? GetValue(int index)
        {
            CheckBounds(index);
            return _source.GetValue(index + _offset);
        }

        /// <inheritdoc />
        public void SetValue(int index, T value)
        {
            CheckBounds(index);
            _source.SetValue(index + _offset, value);
        }

        // --- Appending (Not Supported for Views) ---
        // Views cannot grow, so we explicitly forbid appending.

        /// <summary>
        /// Not supported for SlicedColumn. Slices have a fixed size.
        /// </summary>
        /// <exception cref="NotSupportedException">Always thrown.</exception>
        public void Append(T value)
        {
            throw new NotSupportedException("Cannot append to a SlicedColumn view. Append to the source column instead.");
        }

        /// <summary>
        /// Not supported for SlicedColumn. Slices have a fixed size.
        /// </summary>
        /// <exception cref="NotSupportedException">Always thrown.</exception>
        public void AppendObject(object? value)
        {
            throw new NotSupportedException("Cannot append to a SlicedColumn view. Append to the source column instead.");
        }

        /// <summary>
        /// Not supported for SlicedColumn.
        /// </summary>
        /// <exception cref="NotSupportedException">Always thrown.</exception>
        public void EnsureCapacity(int capacity)
        {
            throw new NotSupportedException("Cannot resize a SlicedColumn view.");
        }

        // --- Slicing ---

        /// <inheritdoc />
        public ReadOnlyMemory<T> Slice(int start, int length)
        {
            CheckBounds(start);
            if (start + length > _length) throw new ArgumentOutOfRangeException(nameof(length));

            // Delegate to source slice with accumulated offset
            return _source.Slice(start + _offset, length);
        }

        /// <inheritdoc />
        public IColumn CloneSubset(IReadOnlyList<int> indices)
        {
            var mappedIndices = new int[indices.Count];
            for (int i = 0; i < indices.Count; i++)
            {
                if (indices[i] < 0 || indices[i] >= _length)
                    throw new IndexOutOfRangeException();

                mappedIndices[i] = indices[i] + _offset;
            }
            return _source.CloneSubset(mappedIndices);
        }

        // --- Null Handling ---

        /// <inheritdoc />
        public bool IsNull(int index)
        {
            CheckBounds(index);
            return _source.IsNull(index + _offset);
        }

        /// <inheritdoc />
        public void SetNull(int index)
        {
            CheckBounds(index);
            _source.SetNull(index + _offset);
        }

        // --- Helpers ---

        /// <inheritdoc />
        public void Dispose()
        {
            // Do nothing. We do NOT own the underlying memory.
        }

        private void CheckBounds(int index)
        {
            if ((uint)index >= (uint)_length)
                throw new IndexOutOfRangeException($"Index {index} is out of slice bounds (Length {_length})");
        }
    }
}
===== FILE: src/LeichtFrame.Core/Columns/StringColumn.cs =====
using System.Buffers;

namespace LeichtFrame.Core
{
    /// <summary>
    /// A column for storing <see cref="string"/> values.
    /// Supports optional string interning (deduplication) to significantly reduce memory usage for categorical data.
    /// </summary>
    public class StringColumn : Column<string?>, IDisposable
    {
        private string?[] _data;
        private NullBitmap? _nulls;
        private int _length;

        // Interning Strategy
        private readonly bool _useInterning;
        private readonly Dictionary<string, string>? _internPool;

        /// <summary>
        /// Initializes a new instance of the <see cref="StringColumn"/> class.
        /// </summary>
        /// <param name="name">The name of the column.</param>
        /// <param name="capacity">The initial capacity (number of rows).</param>
        /// <param name="isNullable">Whether the column supports null values.</param>
        /// <param name="useInterning">
        /// If set to <c>true</c>, enables string deduplication. 
        /// Identical strings will share the same reference in memory. 
        /// Recommended for columns with low cardinality (e.g., "Category", "Country").
        /// </param>
        public StringColumn(string name, int capacity = 16, bool isNullable = false, bool useInterning = false)
            : base(name, isNullable)
        {
            _length = 0;
            _data = ArrayPool<string?>.Shared.Rent(capacity);

            if (isNullable)
            {
                _nulls = new NullBitmap(capacity);
            }

            _useInterning = useInterning;
            if (useInterning)
            {
                _internPool = new Dictionary<string, string>(capacity);
            }
        }

        /// <inheritdoc />
        public override int Length => _length;

        /// <inheritdoc />
        public override ReadOnlyMemory<string?> Values => new ReadOnlyMemory<string?>(_data, 0, _length);

        // --- Core Access ---

        /// <inheritdoc />
        public override string? Get(int index)
        {
            CheckBounds(index);
            if (_nulls != null && _nulls.IsNull(index)) return null;
            return _data[index];
        }

        /// <inheritdoc />
        public override void SetValue(int index, string? value)
        {
            CheckBounds(index);

            if (value == null)
            {
                SetNull(index);
                return;
            }

            if (_useInterning && _internPool != null)
            {
                if (!_internPool.TryGetValue(value, out var interned))
                {
                    _internPool[value] = value;
                    _data[index] = value;
                }
                else
                {
                    _data[index] = interned;
                }
            }
            else
            {
                _data[index] = value;
            }

            _nulls?.SetNotNull(index);
        }

        /// <inheritdoc />
        public override void Append(string? value)
        {
            EnsureCapacity(_length + 1);

            if (value == null)
            {
                if (_nulls == null)
                    throw new InvalidOperationException("Cannot append null to non-nullable column.");

                _data[_length] = null;
                _nulls.SetNull(_length);
            }
            else
            {
                if (_useInterning && _internPool != null)
                {
                    if (!_internPool.TryGetValue(value, out var interned))
                    {
                        _internPool[value] = value;
                        _data[_length] = value;
                    }
                    else
                    {
                        _data[_length] = interned;
                    }
                }
                else
                {
                    _data[_length] = value;
                }

                _nulls?.SetNotNull(_length);
            }
            _length++;
        }

        // --- Null Handling ---

        /// <inheritdoc />
        public override bool IsNull(int index)
        {
            CheckBounds(index);
            return _nulls != null && _nulls.IsNull(index);
        }

        /// <inheritdoc />
        public override void SetNull(int index)
        {
            CheckBounds(index);
            if (_nulls == null) throw new InvalidOperationException("Cannot set null on non-nullable column.");

            _data[index] = null;
            _nulls.SetNull(index);
        }

        /// <inheritdoc />
        public override void SetNotNull(int index)
        {
            CheckBounds(index);
            _nulls?.SetNotNull(index);
        }

        // --- Memory Estimation ---

        /// <summary>
        /// Estimates the total memory usage of this column in bytes.
        /// Includes the internal arrays, the null bitmap, and the approximate size of the string objects on the heap.
        /// </summary>
        /// <returns>The estimated memory size in bytes.</returns>
        public long EstimateMemoryUsage()
        {
            long total = 0;

            total += _data.Length * IntPtr.Size;

            if (_nulls != null) total += _data.Length / 8;

            for (int i = 0; i < _length; i++)
            {
                var s = _data[i];
                if (s != null)
                {
                    total += 24 + (s.Length * 2);
                }
            }

            if (_internPool != null)
            {
                total += _internPool.Count * 64;
            }

            return total;
        }

        // --- Memory Management ---

        /// <inheritdoc />
        public override void EnsureCapacity(int minCapacity)
        {
            if (_data.Length >= minCapacity) return;

            int newCapacity = Math.Max(_data.Length * 2, minCapacity);

            var newBuffer = ArrayPool<string?>.Shared.Rent(newCapacity);
            Array.Copy(_data, newBuffer, _length);

            Array.Clear(_data, 0, _data.Length);
            ArrayPool<string?>.Shared.Return(_data);

            _data = newBuffer;

            _nulls?.Resize(newCapacity);
        }

        private void CheckBounds(int index)
        {
            if ((uint)index >= (uint)_length) throw new IndexOutOfRangeException();
        }

        /// <inheritdoc />
        public override IColumn CloneSubset(IReadOnlyList<int> indices)
        {
            var newCol = new StringColumn(Name, indices.Count, IsNullable);

            for (int i = 0; i < indices.Count; i++)
            {
                int sourceIndex = indices[i];
                if (IsNullable && IsNull(sourceIndex))
                {
                    newCol.Append(null);
                }
                else
                {
                    newCol.Append(Get(sourceIndex));
                }
            }
            return newCol;
        }

        /// <inheritdoc />
        public void Dispose()
        {
            if (_data != null)
            {
                Array.Clear(_data, 0, _data.Length);
                ArrayPool<string?>.Shared.Return(_data);
                _data = null!;
            }
            _nulls?.Dispose();
            _nulls = null;
        }
    }
}
===== FILE: src/LeichtFrame.Core/DataFrame/DataFrame.cs =====
using System.Reflection;
using System.Text;

namespace LeichtFrame.Core
{
    /// <summary>
    /// Represents a high-performance, column-oriented in-memory data table.
    /// Optimized for low memory allocation and fast analytical queries using SIMD and <see cref="Span{T}"/>.
    /// </summary>
    public class DataFrame : IDisposable
    {
        /// <summary>
        /// Creates a new, empty DataFrame based on the provided schema.
        /// Pre-allocates memory for the specified capacity to minimize resize operations.
        /// </summary>
        /// <param name="schema">The schema defining the columns.</param>
        /// <param name="capacity">The initial capacity (number of rows) to reserve.</param>
        /// <returns>A new DataFrame instance.</returns>
        public static DataFrame Create(DataFrameSchema schema, int capacity = 16)
        {
            if (schema == null) throw new ArgumentNullException(nameof(schema));
            if (capacity < 0) throw new ArgumentOutOfRangeException(nameof(capacity));

            var columns = new List<IColumn>(schema.Columns.Count);

            foreach (var colDef in schema.Columns)
            {
                var col = ColumnFactory.Create(colDef.Name, colDef.DataType, capacity, colDef.IsNullable);
                columns.Add(col);
            }

            return new DataFrame(columns);
        }

        /// <summary>
        /// Returns a short summary of the DataFrame (e.g., "DataFrame (1000 rows, 5 columns)").
        /// </summary>
        public override string ToString()
        {
            return $"DataFrame ({RowCount} rows, {ColumnCount} columns)";
        }

        /// <summary>
        /// Generates a formatted string representing the first N rows of the DataFrame.
        /// Useful for console output and debugging.
        /// </summary>
        /// <param name="limit">The maximum number of rows to display (default 10).</param>
        public string Inspect(int limit = 10)
        {
            if (ColumnCount == 0) return "Empty DataFrame";

            var sb = new StringBuilder();
            sb.AppendLine(ToString());
            sb.AppendLine(new string('-', 30));

            int rowsToShow = Math.Min(RowCount, limit);

            // 1. Calculate optimal column widths based on Header and Visible Data
            int[] widths = new int[ColumnCount];
            for (int c = 0; c < ColumnCount; c++)
            {
                var col = _columns[c];
                int maxWidth = col.Name.Length;

                // Consider type name length (e.g., <Int32>)
                maxWidth = Math.Max(maxWidth, col.DataType.Name.Length + 2);

                // Scan visible data for width
                for (int r = 0; r < rowsToShow; r++)
                {
                    object? val = col.GetValue(r);
                    int len = val?.ToString()?.Length ?? 4; // 4 for "null"
                    if (len > maxWidth) maxWidth = len;
                }

                // Limit to a reasonable max (e.g., 50 characters) to prevent console overflow
                widths[c] = Math.Min(maxWidth, 50) + 2; // +2 Padding
            }

            // 2. Print Header (Names)
            for (int c = 0; c < ColumnCount; c++)
            {
                sb.Append(_columns[c].Name.PadRight(widths[c]));
            }
            sb.AppendLine();

            // 3. Print Header (Types)
            for (int c = 0; c < ColumnCount; c++)
            {
                string typeStr = $"<{_columns[c].DataType.Name}>";
                sb.Append(typeStr.PadRight(widths[c]));
            }
            sb.AppendLine();

            // Separator line based on total width
            int totalWidth = widths.Sum();
            sb.AppendLine(new string('-', totalWidth));

            // 4. Print Rows
            for (int r = 0; r < rowsToShow; r++)
            {
                for (int c = 0; c < ColumnCount; c++)
                {
                    object? val = _columns[c].GetValue(r);
                    string valStr = val is null ? "null" : val.ToString() ?? "";

                    // Truncate if too long (Visual Safety)
                    if (valStr.Length > widths[c] - 1)
                        valStr = valStr.Substring(0, widths[c] - 4) + "...";

                    sb.Append(valStr.PadRight(widths[c]));
                }
                sb.AppendLine();
            }

            // 5. Footer hint
            if (RowCount > limit)
            {
                sb.AppendLine(new string('-', 20));
                sb.AppendLine($"... ({RowCount - limit} more rows)");
            }

            return sb.ToString();
        }

        private readonly List<IColumn> _columns;
        private bool _isDisposed;

        /// <summary>
        /// Gets the schema definition of this DataFrame.
        /// </summary>
        public DataFrameSchema Schema { get; }

        /// <summary>
        /// Gets the internal list of columns.
        /// </summary>
        public IReadOnlyList<IColumn> Columns => _columns;

        /// <summary>
        /// Gets the number of rows in the DataFrame.
        /// </summary>
        public int RowCount => _columns.Count > 0 ? _columns[0].Length : 0;

        /// <summary>
        /// Gets the number of columns in the DataFrame.
        /// </summary>
        public int ColumnCount => _columns.Count;

        /// <summary>
        /// Creates a new DataFrame from the provided columns.
        /// Validates that all columns share the same length.
        /// </summary>
        public DataFrame(IEnumerable<IColumn> columns)
        {
            if (columns == null) throw new ArgumentNullException(nameof(columns));

            _columns = columns.ToList();

            // 1. Validation: Row Count Consistency
            if (_columns.Count > 0)
            {
                int expectedLength = _columns[0].Length;
                for (int i = 1; i < _columns.Count; i++)
                {
                    if (_columns[i].Length != expectedLength)
                    {
                        throw new ArgumentException(
                            $"Column length mismatch. Column '{_columns[i].Name}' has length {_columns[i].Length}, " +
                            $"but expected {expectedLength} (from '{_columns[0].Name}').");
                    }
                }
            }

            // 2. Build Schema automatically from column metadata
            var definitions = _columns.Select(c => new ColumnDefinition(c.Name, c.DataType, c.IsNullable));
            Schema = new DataFrameSchema(definitions);
        }

        /// <summary>
        /// Gets the column at the specified index.
        /// </summary>
        public IColumn this[int index] => _columns[index];

        /// <summary>
        /// Gets the column with the specified name.
        /// Throws <see cref="ArgumentException"/> if the column does not exist.
        /// </summary>
        public IColumn this[string name]
        {
            get
            {
                // Schema lookup handles the exception if name is missing
                int index = Schema.GetColumnIndex(name);
                return _columns[index];
            }
        }

        /// <summary>
        /// Tries to get the column with the specified name.
        /// Returns true if found, otherwise false.
        /// </summary>
        public bool TryGetColumn(string name, out IColumn? column)
        {
            if (Schema.HasColumn(name))
            {
                int index = Schema.GetColumnIndex(name);
                column = _columns[index];
                return true;
            }

            column = null;
            return false;
        }

        /// <summary>
        /// Creates a DataFrame from a collection of objects (POCOs) using Reflection.
        /// The schema is automatically generated from the public properties of <typeparamref name="T"/>.
        /// </summary>
        /// <typeparam name="T">The type of the objects, determining the schema.</typeparam>
        /// <param name="objects">The collection of objects to load.</param>
        /// <returns>A populated DataFrame containing the data from the objects.</returns>
        public static DataFrame FromObjects<T>(IEnumerable<T> objects)
        {
            if (objects == null) throw new ArgumentNullException(nameof(objects));

            // 1. Get Schema via centralized logic
            var schema = DataFrameSchema.FromType<T>();

            // 2. Prepare for data population
            int estimatedCount = objects is ICollection<T> coll ? coll.Count : 16;
            var df = DataFrame.Create(schema, estimatedCount);

            // Cache PropertyInfos for speed
            var type = typeof(T);
            var propMap = new Dictionary<string, PropertyInfo>();
            foreach (var col in df.Columns)
            {
                propMap[col.Name] = type.GetProperty(col.Name)!;
            }

            // 3. Populate Data
            foreach (var item in objects)
            {
                foreach (var col in df.Columns)
                {
                    var prop = propMap[col.Name];
                    object? val = prop.GetValue(item);
                    col.AppendObject(val);
                }
            }

            return df;
        }

        /// <summary>
        /// Disposes all contained columns, returning their memory to the pool.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }


        /// <summary>
        /// Releases unmanaged and - optionally - managed resources.
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (_isDisposed) return;

            if (disposing)
            {
                foreach (var col in _columns)
                {
                    // Check if the column implements IDisposable (our concrete columns do)
                    if (col is IDisposable disposableCol)
                    {
                        disposableCol.Dispose();
                    }
                }
            }
            _isDisposed = true;
        }

        /// <summary>
        /// Checks if a column with the given name exists in the DataFrame.
        /// </summary>
        public bool HasColumn(string name)
        {
            if (string.IsNullOrEmpty(name)) return false;
            return Schema.HasColumn(name);
        }

        /// <summary>
        /// Returns the names of all columns in the DataFrame.
        /// </summary>
        public IEnumerable<string> GetColumnNames()
        {
            return _columns.Select(c => c.Name);
        }

        /// <summary>
        /// Returns the .NET Type of the data stored in the specified column.
        /// Throws ArgumentException if the column does not exist.
        /// </summary>
        public Type GetColumnType(string name)
        {
            // We use the existing indexer, which already handles validation/exception
            return this[name].DataType;
        }
    }
}
===== FILE: src/LeichtFrame.Core/DataFrame/DataFrameSchema.cs =====
using System.Text.Json;

namespace LeichtFrame.Core;

/// <summary>
/// Defines the metadata for a single column within a DataFrame schema.
/// </summary>
/// <param name="Name">The unique name of the column.</param>
/// <param name="DataType">The CLR type of the data stored in the column.</param>
/// <param name="IsNullable">Indicates if the column supports null values.</param>
public record ColumnDefinition(string Name, Type DataType, bool IsNullable = false);

/// <summary>
/// Represents the structure of a DataFrame, consisting of a collection of column definitions.
/// Provides lookup methods for column indices and types.
/// </summary>
public class DataFrameSchema
{
    private readonly List<ColumnDefinition> _columns;
    private readonly Dictionary<string, int> _nameMap;

    /// <summary>
    /// Gets the list of column definitions in this schema.
    /// </summary>
    public IReadOnlyList<ColumnDefinition> Columns => _columns;

    /// <summary>
    /// Initializes a new instance of the <see cref="DataFrameSchema"/> class.
    /// </summary>
    /// <param name="columns">The collection of column definitions.</param>
    /// <exception cref="ArgumentNullException">Thrown if columns is null.</exception>
    /// <exception cref="ArgumentException">Thrown if duplicate column names are detected.</exception>
    public DataFrameSchema(IEnumerable<ColumnDefinition> columns)
    {
        _columns = columns?.ToList() ?? throw new ArgumentNullException(nameof(columns));
        _nameMap = new Dictionary<string, int>();

        // Build lookup dictionary for fast access
        for (int i = 0; i < _columns.Count; i++)
        {
            var col = _columns[i];
            if (_nameMap.ContainsKey(col.Name))
                throw new ArgumentException($"Duplicate column name '{col.Name}' is not allowed.");

            _nameMap[col.Name] = i;
        }
    }

    /// <summary>
    /// Checks if a column with the given name exists in the schema.
    /// </summary>
    /// <param name="name">The name of the column to check.</param>
    /// <returns><c>true</c> if the column exists; otherwise, <c>false</c>.</returns>
    public bool HasColumn(string name) => _nameMap.ContainsKey(name);

    /// <summary>
    /// Gets the zero-based index of the column with the specified name.
    /// </summary>
    /// <param name="name">The name of the column.</param>
    /// <returns>The index of the column.</returns>
    /// <exception cref="ArgumentException">Thrown if the column does not exist.</exception>
    public int GetColumnIndex(string name)
    {
        if (_nameMap.TryGetValue(name, out int index))
            return index;

        throw new ArgumentException($"Column '{name}' does not exist in the schema.");
    }

    // --- JSON Serialization Logic ---

    /// <summary>
    /// Serializes the schema to a JSON string representation.
    /// Useful for persisting metadata or transferring schemas between processes.
    /// </summary>
    /// <returns>A JSON string defining the schema.</returns>
    public string ToJson()
    {
        // Convert to DTO because System.Type implies security risks and complexity in raw JSON. We store the Type Name as a string.
        var dto = new SchemaDto
        {
            Columns = _columns.Select(c => new ColumnDto
            {
                Name = c.Name,
                DataTypeName = c.DataType.AssemblyQualifiedName ?? c.DataType.FullName ?? c.DataType.Name,
                IsNullable = c.IsNullable
            }).ToList()
        };

        return JsonSerializer.Serialize(dto, new JsonSerializerOptions { WriteIndented = true });
    }

    /// <summary>
    /// Creates a <see cref="DataFrameSchema"/> from a JSON string.
    /// </summary>
    /// <param name="json">The JSON string containing the schema definition.</param>
    /// <returns>The deserialized schema.</returns>
    /// <exception cref="ArgumentException">Thrown if the JSON is invalid.</exception>
    public static DataFrameSchema FromJson(string json)
    {
        var dto = JsonSerializer.Deserialize<SchemaDto>(json);
        if (dto == null || dto.Columns == null)
            throw new ArgumentException("Invalid JSON schema.");

        var definitions = dto.Columns.Select(c => new ColumnDefinition(
            c.Name,
            Type.GetType(c.DataTypeName) ?? throw new InvalidOperationException($"Type '{c.DataTypeName}' not found."),
            c.IsNullable
        ));

        return new DataFrameSchema(definitions);
    }

    /// <summary>
    /// Helper to get the <see cref="Type"/> of a column by name.
    /// </summary>
    /// <param name="name">The column name.</param>
    /// <returns>The data type of the column.</returns>
    /// <exception cref="ArgumentException">Thrown if the column does not exist.</exception>
    public Type GetColumnType(string name)
    {
        int index = GetColumnIndex(name); // Wirft Fehler, wenn nicht gefunden
        return _columns[index].DataType;
    }

    // --- Private Helper Classes for JSON ---
    private class SchemaDto
    {
        public List<ColumnDto> Columns { get; set; } = new();
    }

    private class ColumnDto
    {
        public string Name { get; set; } = string.Empty;
        public string DataTypeName { get; set; } = string.Empty;
        public bool IsNullable { get; set; }
    }

    /// <summary>
    /// Creates a schema definition automatically from a C# class (POCO) using Reflection.
    /// Only supported primitive types (int, double, bool, string, DateTime) are mapped.
    /// </summary>
    /// <typeparam name="T">The POCO type to analyze.</typeparam>
    /// <returns>A derived <see cref="DataFrameSchema"/>.</returns>
    /// <exception cref="ArgumentException">Thrown if the type has no supported public properties.</exception>
    public static DataFrameSchema FromType<T>()
    {
        var properties = typeof(T).GetProperties(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);
        var colDefs = new List<ColumnDefinition>();

        foreach (var prop in properties)
        {
            Type type = prop.PropertyType;
            // Unbox Nullable<T> -> T
            Type coreType = Nullable.GetUnderlyingType(type) ?? type;
            bool isNullable = !type.IsValueType || Nullable.GetUnderlyingType(type) != null;

            // Supported Types Check
            if (coreType != typeof(int) && coreType != typeof(double) &&
                coreType != typeof(string) && coreType != typeof(bool) &&
                coreType != typeof(DateTime))
            {
                continue; // Skip unsupported types
            }

            colDefs.Add(new ColumnDefinition(prop.Name, coreType, isNullable));
        }

        if (colDefs.Count == 0)
            throw new ArgumentException($"Type '{typeof(T).Name}' has no supported public properties.");

        return new DataFrameSchema(colDefs);
    }
}
===== FILE: src/LeichtFrame.Core/DataFrame/GroupedDataFrame.cs =====
namespace LeichtFrame.Core
{
    /// <summary>
    /// Represents an intermediate state of a DataFrame grouped by a specific column.
    /// Used to perform aggregated calculations per group.
    /// </summary>
    public class GroupedDataFrame
    {
        private readonly Dictionary<object, List<int>> _groupMap;

        /// <summary>
        /// The original DataFrame.
        /// </summary>
        public DataFrame Source { get; }

        /// <summary>
        /// The name of the column used for grouping.
        /// </summary>
        public string GroupColumnName { get; }

        /// <summary>
        /// Access to the internal grouping map.
        /// Key: The value of the group (e.g., "Berlin" or 42).
        /// Value: List of row indices belonging to this group.
        /// </summary>
        public IReadOnlyDictionary<object, List<int>> GroupMap => _groupMap;

        internal GroupedDataFrame(DataFrame source, string groupColName, Dictionary<object, List<int>> groupMap)
        {
            Source = source;
            GroupColumnName = groupColName;
            _groupMap = groupMap;
        }
    }
}
===== FILE: src/LeichtFrame.Core/DataFrame/Operations/AggregationOps.cs =====
namespace LeichtFrame.Core
{
    /// <summary>
    /// Provides extension methods for calculating aggregations (Sum, Min, Max, Mean) on DataFrames.
    /// </summary>
    public static class DataFrameAggregationExtensions
    {
        /// <summary>
        /// Calculates the Sum of a numeric column. Ignores null values.
        /// Returns 0 if column is empty.
        /// </summary>
        /// <param name="df">The DataFrame to operate on.</param>
        /// <param name="columnName">The name of the column to sum.</param>
        /// <returns>The sum as a double.</returns>
        /// <exception cref="NotSupportedException">Thrown if the column type is not numeric.</exception>
        public static double Sum(this DataFrame df, string columnName)
        {
            var col = df[columnName];

            // 1. Double Optimization
            if (col is DoubleColumn doubleCol)
            {
                return doubleCol.Sum();
            }

            // 2. Int Optimization (Direct Span Access)
            if (col is IntColumn intCol)
            {
                var span = intCol.Values.Span;
                long sum = 0;

                // Fast Path for Non-Nullable (No Bit-Check needed)
                if (!intCol.IsNullable)
                {
                    foreach (var val in span) sum += val;
                }
                else
                {
                    // Safe Path for Nullable
                    for (int i = 0; i < intCol.Length; i++)
                    {
                        if (!intCol.IsNull(i)) sum += span[i];
                    }
                }
                return (double)sum;
            }

            throw new NotSupportedException($"Sum operation is not supported for column type '{col.DataType.Name}'.");
        }

        /// <summary>
        /// Calculates the Minimum value of a numeric column. Ignores null values.
        /// Returns 0 (or default) if no values exist.
        /// </summary>
        /// <param name="df">The DataFrame to operate on.</param>
        /// <param name="columnName">The name of the column.</param>
        /// <returns>The minimum value found.</returns>
        public static double Min(this DataFrame df, string columnName)
        {
            var col = df[columnName];

            if (col is DoubleColumn doubleCol) return doubleCol.Min();

            if (col is IntColumn intCol)
            {
                if (intCol.Length == 0) return 0;

                int min = int.MaxValue;
                bool hasValue = false;
                var span = intCol.Values.Span;

                for (int i = 0; i < intCol.Length; i++)
                {
                    if (!intCol.IsNullable || !intCol.IsNull(i))
                    {
                        var val = span[i];
                        if (val < min) min = val;
                        hasValue = true;
                    }
                }
                return hasValue ? min : 0;
            }

            throw new NotSupportedException($"Min operation is not supported for column type '{col.DataType.Name}'.");
        }

        /// <summary>
        /// Calculates the Maximum value of a numeric column. Ignores null values.
        /// </summary>
        /// <param name="df">The DataFrame to operate on.</param>
        /// <param name="columnName">The name of the column.</param>
        /// <returns>The maximum value found.</returns>
        public static double Max(this DataFrame df, string columnName)
        {
            var col = df[columnName];

            if (col is DoubleColumn doubleCol) return doubleCol.Max();

            if (col is IntColumn intCol)
            {
                if (intCol.Length == 0) return 0;

                int max = int.MinValue;
                bool hasValue = false;
                var span = intCol.Values.Span;

                for (int i = 0; i < intCol.Length; i++)
                {
                    if (!intCol.IsNullable || !intCol.IsNull(i))
                    {
                        var val = span[i];
                        if (val > max) max = val;
                        hasValue = true;
                    }
                }
                return hasValue ? max : 0;
            }

            throw new NotSupportedException($"Max operation is not supported for column type '{col.DataType.Name}'.");
        }

        /// <summary>
        /// Calculates the arithmetic Mean (Average) of a numeric column. Ignores null values.
        /// </summary>
        /// <param name="df">The DataFrame to operate on.</param>
        /// <param name="columnName">The name of the column.</param>
        /// <returns>The average value.</returns>
        public static double Mean(this DataFrame df, string columnName)
        {
            // Mean = Sum / Count (of non-nulls)

            var col = df[columnName];
            double sum = df.Sum(columnName);
            int count = 0;

            // We need to count the number of valid (non-null) values
            if (col.IsNullable)
            {
                // Unfortunately, we have to loop here unless we had a "NullCount" property (feature for later?)
                // For now: Simple loop.
                if (col is IntColumn ic)
                {
                    for (int i = 0; i < ic.Length; i++) if (!ic.IsNull(i)) count++;
                }
                else if (col is DoubleColumn dc)
                {
                    for (int i = 0; i < dc.Length; i++) if (!dc.IsNull(i)) count++;
                }
            }
            else
            {
                count = col.Length;
            }

            if (count == 0) return 0;
            return sum / count;
        }
    }

    /// <summary>
    /// Provides extension methods for performing aggregations on grouped dataframes.
    /// </summary>
    public static class GroupAggregationExtensions
    {
        /// <summary>
        /// Aggregates the grouped data by counting rows in each group.
        /// Returns a new DataFrame with columns: [GroupColumn, "Count"].
        /// </summary>
        /// <param name="gdf">The grouped dataframe.</param>
        /// <returns>A new dataframe containing the group keys and their counts.</returns>
        public static DataFrame Count(this GroupedDataFrame gdf)
        {
            // 1. Prepare Columns
            var sourceKeyCol = gdf.Source[gdf.GroupColumnName];

            // Key Column (Same type as source grouping column)
            var keyCol = ColumnFactory.Create(gdf.GroupColumnName, sourceKeyCol.DataType, gdf.GroupMap.Count, sourceKeyCol.IsNullable);

            // Result Column (Always Int for Count)
            var countCol = new IntColumn("Count", gdf.GroupMap.Count);

            // 2. Iterate Groups
            foreach (var kvp in gdf.GroupMap)
            {
                object key = kvp.Key;
                List<int> indices = kvp.Value;

                // Handle Sentinel for Null Key
                object? realKey = DataFrameGroupingExtensions.GetRealValue(key);

                // Helper to append object to specific column type (Reflection/Cast needed here if we don't know T)
                // As our Column API is strongly typed (.Append(int)), but here we have 'object',
                // we need a small helper or casts.
                // For MVP we use a dynamic cast or pattern matching.
                AppendKey(keyCol, realKey);

                // Set Count
                countCol.Append(indices.Count);
            }

            return new DataFrame(new[] { keyCol, countCol });
        }

        /// <summary>
        /// Aggregates the grouped data by summing values in the specified column.
        /// Returns a new DataFrame with columns: [GroupColumn, "Sum_TargetColumn"].
        /// </summary>
        /// <param name="gdf">The grouped dataframe.</param>
        /// <param name="aggregateColumnName">The column to sum up per group.</param>
        /// <returns>A new dataframe containing the group keys and the sums.</returns>
        public static DataFrame Sum(this GroupedDataFrame gdf, string aggregateColumnName)
        {
            var sourceKeyCol = gdf.Source[gdf.GroupColumnName];
            var valueCol = gdf.Source[aggregateColumnName];

            // 1. Prepare Result Structure
            var keyCol = ColumnFactory.Create(gdf.GroupColumnName, sourceKeyCol.DataType, gdf.GroupMap.Count, sourceKeyCol.IsNullable);
            var sumCol = new DoubleColumn($"Sum_{aggregateColumnName}", gdf.GroupMap.Count);

            // 2. Perform Aggregation based on Type
            // We need to distinguish to sum efficiently
            if (valueCol is IntColumn intCol)
            {
                foreach (var kvp in gdf.GroupMap)
                {
                    AppendKey(keyCol, DataFrameGroupingExtensions.GetRealValue(kvp.Key));

                    long groupSum = 0;
                    foreach (var idx in kvp.Value)
                    {
                        // Direct access via Get(i) is fast enough for aggregations
                        if (!intCol.IsNullable || !intCol.IsNull(idx))
                            groupSum += intCol.Get(idx);
                    }
                    sumCol.Append(groupSum);
                }
            }
            else if (valueCol is DoubleColumn dblCol)
            {
                foreach (var kvp in gdf.GroupMap)
                {
                    AppendKey(keyCol, DataFrameGroupingExtensions.GetRealValue(kvp.Key));

                    double groupSum = 0;
                    foreach (var idx in kvp.Value)
                    {
                        if (!dblCol.IsNullable || !dblCol.IsNull(idx))
                            groupSum += dblCol.Get(idx);
                    }
                    sumCol.Append(groupSum);
                }
            }
            else
            {
                throw new NotSupportedException($"Sum not supported for column '{aggregateColumnName}' of type {valueCol.DataType.Name}");
            }

            return new DataFrame(new IColumn[] { keyCol, sumCol });
        }

        // --- Helper to append untyped object to typed column ---
        private static void AppendKey(IColumn col, object? value)
        {
            if (value == null)
            {
                // Reflection to find "Append(T?)" is hard, but we can assume concrete types for MVP
                if (col is IntColumn ic) ic.Append(null);
                else if (col is DoubleColumn dc) dc.Append(null);
                else if (col is StringColumn sc) sc.Append(null);
                else if (col is BoolColumn bc) bc.Append(null);
                else if (col is DateTimeColumn dtc) dtc.Append(null);
                return;
            }

            if (col is IntColumn i) i.Append((int)value);
            else if (col is StringColumn s) s.Append((string)value);
            else if (col is DoubleColumn d) d.Append((double)value);
            else if (col is BoolColumn b) b.Append((bool)value);
            else if (col is DateTimeColumn dt) dt.Append((DateTime)value);
            else throw new NotSupportedException($"Unknown column type for key: {col.GetType().Name}");
        }
    }
}
===== FILE: src/LeichtFrame.Core/DataFrame/Operations/FilterOps.cs =====
namespace LeichtFrame.Core
{
    /// <summary>
    /// Provides extension methods for filtering <see cref="DataFrame"/> rows based on predicates.
    /// </summary>
    public static class DataFrameFilterExtensions
    {
        /// <summary>
        /// Filters rows based on a predicate function.
        /// Creates a new <see cref="DataFrame"/> with COPIED data containing only the matching rows.
        /// </summary>
        /// <param name="df">The source DataFrame.</param>
        /// <param name="predicate">A function to test each row. Return <c>true</c> to keep the row, <c>false</c> to drop it.</param>
        /// <returns>A new DataFrame containing only the rows that satisfy the condition.</returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="predicate"/> is null.</exception>
        public static DataFrame Where(this DataFrame df, Func<RowView, bool> predicate)
        {
            if (predicate == null) throw new ArgumentNullException(nameof(predicate));

            // 1. Phase: Scan (Collect indices)
            // We use a capacity estimate to minimize resizing of the list
            var indices = new List<int>(df.RowCount / 2);

            // RowView is a struct (stack-only), so very cheap to create
            for (int i = 0; i < df.RowCount; i++)
            {
                var row = new RowView(i, df.Columns, df.Schema);
                if (predicate(row))
                {
                    indices.Add(i);
                }
            }

            // 2. Phase: Copy (Column-wise)
            var newColumns = new List<IColumn>(df.ColumnCount);
            foreach (var col in df.Columns)
            {
                // Each column takes care of efficiently copying the indices
                newColumns.Add(col.CloneSubset(indices));
            }

            return new DataFrame(newColumns);
        }
    }
}
===== FILE: src/LeichtFrame.Core/DataFrame/Operations/GroupingOps.cs =====
namespace LeichtFrame.Core
{
    /// <summary>
    /// Provides extension methods for grouping operations on <see cref="DataFrame"/>.
    /// </summary>
    public static class DataFrameGroupingExtensions
    {
        // Sentinel object to represent 'null' in the dictionary key
        private static readonly object NullKey = new object();

        /// <summary>
        /// Groups the rows of the DataFrame by the values in the specified column.
        /// Uses a Hash-Map approach (O(n)).
        /// </summary>
        /// <param name="df">The source DataFrame.</param>
        /// <param name="columnName">The name of the column to group by.</param>
        /// <returns>A <see cref="GroupedDataFrame"/> object used to apply aggregations.</returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="columnName"/> is null or empty.</exception>
        public static GroupedDataFrame GroupBy(this DataFrame df, string columnName)
        {
            if (string.IsNullOrEmpty(columnName)) throw new ArgumentNullException(nameof(columnName));

            var col = df[columnName];
            var groups = new Dictionary<object, List<int>>();

            // We iterate over all rows (O(n))
            for (int i = 0; i < df.RowCount; i++)
            {
                // 1. Get value (untyped is okay here for MVP, as GroupBy key is usually object-like)
                // Optimization idea for later: Generic implementation for IntColumn to avoid boxing.
                object? val = col.GetValue(i);

                // 2. Null-Handling for Dictionary Key
                object key = val ?? NullKey;

                // 3. Insert into bucket
                // (net8.0 allows CollectionsMarshal for high-perf, but here standard way for readability)
                if (!groups.TryGetValue(key, out var indices))
                {
                    indices = new List<int>();
                    groups[key] = indices;
                }

                indices.Add(i);
            }

            return new GroupedDataFrame(df, columnName, groups);
        }

        /// <summary>
        /// Helper to retrieve the original value from a dictionary key (converts NullKey back to null).
        /// </summary>
        internal static object? GetRealValue(object key)
        {
            return ReferenceEquals(key, NullKey) ? null : key;
        }
    }
}
===== FILE: src/LeichtFrame.Core/DataFrame/Operations/JoinOps.cs =====
using System;
using System.Collections.Generic;
using System.Linq;

namespace LeichtFrame.Core
{
    /// <summary>
    /// Provides extension methods for joining multiple <see cref="DataFrame"/> objects.
    /// </summary>
    public static class DataFrameJoinExtensions
    {
        /// <summary>
        /// Joins two DataFrames based on a common key column using a Hash Join algorithm.
        /// </summary>
        /// <param name="left">The left DataFrame (the source of the method call).</param>
        /// <param name="right">The right DataFrame to join against.</param>
        /// <param name="on">The name of the column to use as the join key. Must exist in both DataFrames.</param>
        /// <param name="joinType">The type of join to perform (e.g., Inner). Currently, only <see cref="JoinType.Inner"/> is supported.</param>
        /// <returns>A new <see cref="DataFrame"/> containing columns from both sources, matched by the key.</returns>
        /// <exception cref="NotImplementedException">Thrown if <paramref name="joinType"/> is not Inner.</exception>
        /// <exception cref="NotSupportedException">Thrown if there are column name collisions between the two DataFrames.</exception>
        public static DataFrame Join(this DataFrame left, DataFrame right, string on, JoinType joinType = JoinType.Inner)
        {
            if (joinType != JoinType.Inner)
                throw new NotImplementedException("Only Inner Join is currently supported.");

            var leftKeyCol = left[on];
            var rightKeyCol = right[on];

            // 1. Build Phase: Create Hash Map from right table
            // Key: Cell value, Value: List of row indices
            var hashTable = new Dictionary<object, List<int>>();
            object nullSentinel = new object(); // Placeholder for null values

            for (int r = 0; r < right.RowCount; r++)
            {
                // Get value (handle null safely)
                object key = rightKeyCol.GetValue(r) ?? nullSentinel;

                if (!hashTable.TryGetValue(key, out var indices))
                {
                    indices = new List<int>();
                    hashTable[key] = indices;
                }
                indices.Add(r);
            }

            // 2. Probe Phase: Scan left table and find matches
            var leftIndices = new List<int>();
            var rightIndices = new List<int>();

            for (int l = 0; l < left.RowCount; l++)
            {
                object key = leftKeyCol.GetValue(l) ?? nullSentinel;

                if (hashTable.TryGetValue(key, out var matchingRightIndices))
                {
                    // Match found! (Can be 1:N)
                    foreach (var rIdx in matchingRightIndices)
                    {
                        leftIndices.Add(l);
                        rightIndices.Add(rIdx);
                    }
                }
            }

            // 3. Materialize Phase: Create new columns
            var newColumns = new List<IColumn>();

            // 3a. Copy all left columns (only matching rows)
            foreach (var col in left.Columns)
            {
                newColumns.Add(col.CloneSubset(leftIndices));
            }

            // 3b. Add right columns
            foreach (var col in right.Columns)
            {
                // Skip the join key column from the right (we already have it from the left)
                if (col.Name == on) continue;

                // Check for name conflicts (for MVP we throw an error)
                if (left.Schema.HasColumn(col.Name))
                {
                    throw new NotSupportedException(
                        $"Column name collision: '{col.Name}' exists in both DataFrames. Please rename columns before joining.");
                }

                newColumns.Add(col.CloneSubset(rightIndices));
            }

            return new DataFrame(newColumns);
        }
    }
}
===== FILE: src/LeichtFrame.Core/DataFrame/Operations/SelectionOps.cs =====
namespace LeichtFrame.Core
{
    /// <summary>
    /// Provides extension methods for selecting columns and slicing rows from a <see cref="DataFrame"/>.
    /// </summary>
    public static class DataFrameSelectionExtensions
    {
        /// <summary>
        /// Projects the DataFrame to a new DataFrame containing only the selected columns.
        /// This is a Zero-Copy operation: The new DataFrame shares the underlying column data with the original.
        /// </summary>
        /// <param name="df">The source DataFrame.</param>
        /// <param name="columnNames">The names of the columns to select.</param>
        /// <returns>A new DataFrame instance containing the selected columns.</returns>
        public static DataFrame Select(this DataFrame df, params string[] columnNames)
        {
            if (df == null) throw new ArgumentNullException(nameof(df));
            if (columnNames == null || columnNames.Length == 0)
                throw new ArgumentException("At least one column must be selected.", nameof(columnNames));

            // We collect the column references from the original.
            var selectedColumns = new List<IColumn>(columnNames.Length);

            foreach (var name in columnNames)
            {
                selectedColumns.Add(df[name]);
            }

            // Create a new container with the same column instances.
            return new DataFrame(selectedColumns);
        }

        /// <summary>
        /// Returns a zero-copy view of the DataFrame restricted to the specified row range.
        /// </summary>
        /// <param name="df">The source DataFrame.</param>
        /// <param name="start">The zero-based starting row index.</param>
        /// <param name="length">The number of rows to include in the slice.</param>
        /// <returns>A new DataFrame containing the subset of rows.</returns>
        public static DataFrame Slice(this DataFrame df, int start, int length)
        {
            if (start < 0) throw new ArgumentOutOfRangeException(nameof(start));

            // Bounds adjusting (Robustness)
            if (start >= df.RowCount)
            {
                // Return empty DataFrame with same schema
                return DataFrame.Create(df.Schema, 0);
            }

            int validLength = Math.Min(length, df.RowCount - start);

            var newColumns = new List<IColumn>(df.ColumnCount);

            foreach (var col in df.Columns)
            {
                // Magic: Create SlicedColumn<T> dynamically
                var genericType = typeof(SlicedColumn<>).MakeGenericType(col.DataType);

                // Invoke Constructor: SlicedColumn(source, offset, length)
                var slicedCol = Activator.CreateInstance(genericType, col, start, validLength);

                newColumns.Add((IColumn)slicedCol!);
            }

            return new DataFrame(newColumns);
        }

        /// <summary>
        /// Returns the first <paramref name="count"/> rows of the DataFrame.
        /// </summary>
        /// <param name="df">The source DataFrame.</param>
        /// <param name="count">The number of rows to return from the beginning.</param>
        /// <returns>A new DataFrame containing the first rows.</returns>
        public static DataFrame Head(this DataFrame df, int count)
        {
            return df.Slice(0, count);
        }

        /// <summary>
        /// Returns the last <paramref name="count"/> rows of the DataFrame.
        /// </summary>
        /// <param name="df">The source DataFrame.</param>
        /// <param name="count">The number of rows to return from the end.</param>
        /// <returns>A new DataFrame containing the last rows.</returns>
        public static DataFrame Tail(this DataFrame df, int count)
        {
            int start = Math.Max(0, df.RowCount - count);
            // length is count, but Slice logic handles if start+count > RowCount (though here it matches)
            int length = Math.Min(count, df.RowCount);
            return df.Slice(start, length);
        }
    }
}
===== FILE: src/LeichtFrame.Core/DataFrame/RowView.cs =====
using System;
using System.Collections.Generic;

namespace LeichtFrame.Core
{
    /// <summary>
    /// Represents a lightweight, read-only view of a single row in a <see cref="DataFrame"/>.
    /// Acts as a zero-copy cursor enabling row-based operations without materializing objects.
    /// </summary>
    public readonly struct RowView
    {
        private readonly int _rowIndex;
        private readonly IReadOnlyList<IColumn> _columns;
        private readonly DataFrameSchema _schema;

        /// <summary>
        /// Initializes a new instance of the <see cref="RowView"/> struct.
        /// </summary>
        /// <param name="rowIndex">The zero-based index of the row.</param>
        /// <param name="columns">The list of columns backing the data.</param>
        /// <param name="schema">The schema definition for column name lookups.</param>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if rowIndex is negative.</exception>
        /// <exception cref="ArgumentNullException">Thrown if columns or schema are null.</exception>
        public RowView(int rowIndex, IReadOnlyList<IColumn> columns, DataFrameSchema schema)
        {
            if (rowIndex < 0) throw new ArgumentOutOfRangeException(nameof(rowIndex));
            _rowIndex = rowIndex;
            _columns = columns ?? throw new ArgumentNullException(nameof(columns));
            _schema = schema ?? throw new ArgumentNullException(nameof(schema));
        }

        /// <summary>
        /// Gets the strongly-typed value from the specified column index.
        /// This is the fastest way to access data within a row.
        /// </summary>
        /// <typeparam name="T">The expected type of the value.</typeparam>
        /// <param name="columnIndex">The zero-based index of the column.</param>
        /// <returns>The value of type T.</returns>
        /// <exception cref="InvalidCastException">Thrown if the column type does not match T.</exception>
        public T Get<T>(int columnIndex)
        {
            var col = _columns[columnIndex];

            // Pattern matching on generic interface
            if (col is IColumn<T> typedCol)
            {
                return typedCol.GetValue(_rowIndex);
            }

            throw new InvalidCastException(
                $"Column '{col.Name}' is type {col.DataType.Name}, but '{typeof(T).Name}' was requested.");
        }

        /// <summary>
        /// Gets the strongly-typed value from the column with the specified name.
        /// </summary>
        /// <typeparam name="T">The expected type of the value.</typeparam>
        /// <param name="columnName">The name of the column.</param>
        /// <returns>The value of type T.</returns>
        /// <exception cref="ArgumentException">Thrown if the column name does not exist.</exception>
        public T Get<T>(string columnName)
        {
            int index = _schema.GetColumnIndex(columnName);
            return Get<T>(index);
        }

        /// <summary>
        /// Gets the value at the specified column index as an object (boxed).
        /// </summary>
        /// <param name="columnIndex">The zero-based index of the column.</param>
        /// <returns>The value as an object, or null.</returns>
        public object? GetValue(int columnIndex)
        {
            return _columns[columnIndex].GetValue(_rowIndex);
        }

        // Indexer for convenience

        /// <summary>
        /// Gets the value at the specified column index (untyped).
        /// </summary>
        /// <param name="index">The zero-based column index.</param>
        public object? this[int index] => GetValue(index);

        /// <summary>
        /// Gets the value of the column with the specified name (untyped).
        /// </summary>
        /// <param name="name">The name of the column.</param>
        public object? this[string name] => GetValue(_schema.GetColumnIndex(name));
    }
}
===== FILE: src/LeichtFrame.Core/Extensions/ColumnExtensions.cs =====
using System;

namespace LeichtFrame.Core
{
    /// <summary>
    /// Provides helper extension methods for interacting with <see cref="IColumn"/> instances.
    /// </summary>
    public static class ColumnExtensions
    {
        /// <summary>
        /// Helper extension to get a typed value from a generic <see cref="IColumn"/>.
        /// Performs a cast and calls the typed GetValue method if possible.
        /// </summary>
        /// <typeparam name="T">The expected return type.</typeparam>
        /// <param name="column">The column instance.</param>
        /// <param name="index">The row index to retrieve.</param>
        /// <returns>The value of type T.</returns>
        /// <exception cref="InvalidCastException">Thrown if the column type does not match T.</exception>
        public static T Get<T>(this IColumn column, int index)
        {
            // Fast Path: If it is already the correct typed interface
            if (column is IColumn<T> typedCol)
            {
                return typedCol.GetValue(index);
            }

            // Slow Path: Type does not match or is unknown -> Exception or Convert
            throw new InvalidCastException(
                $"Column '{column.Name}' is of type {column.DataType.Name}, but '{typeof(T).Name}' was requested.");
        }

        /// <summary>
        /// Appends an untyped object value to the column. 
        /// Handles type checking and dispatching to the concrete Append method.
        /// </summary>
        /// <param name="column">The target column.</param>
        /// <param name="value">The value to append (can be null if supported).</param>
        /// <exception cref="NotSupportedException">Thrown if the value type is incompatible or the column type is unknown.</exception>
        public static void AppendObject(this IColumn column, object? value)
        {
            if (value == null)
            {
                // We must unfortunately know which concrete types support Append(null).
                // Since IColumn does not have Append (only the concrete classes), we cast.
                if (column is IntColumn ic) ic.Append(null);
                else if (column is DoubleColumn dc) dc.Append(null);
                else if (column is StringColumn sc) sc.Append(null);
                else if (column is BoolColumn bc) bc.Append(null);
                else if (column is DateTimeColumn dtc) dtc.Append(null);
                else throw new NotSupportedException($"Column '{column.Name}' does not support null values or type is unknown.");
                return;
            }

            // Type dispatch
            if (column is IntColumn i) i.Append((int)value);
            else if (column is DoubleColumn d) d.Append(Convert.ToDouble(value)); // Convert allows int->double
            else if (column is StringColumn s) s.Append(value.ToString());
            else if (column is BoolColumn b) b.Append((bool)value);
            else if (column is DateTimeColumn dt) dt.Append((DateTime)value);
            else
                throw new NotSupportedException($"Cannot append object of type {value.GetType().Name} to column {column.GetType().Name}");
        }
    }
}
===== FILE: src/LeichtFrame.Core/JoinType.cs =====
namespace LeichtFrame.Core
{
    /// <summary>
    /// Specifies the type of join operation to perform when combining two DataFrames.
    /// </summary>
    public enum JoinType
    {
        /// <summary>
        /// Returns records that have matching values in both tables.
        /// </summary>
        Inner
        // Left, Right, Full (tbd)
    }
}
===== FILE: src/LeichtFrame.Core/LeichtFrame.Core.csproj =====
Ôªø<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>

===== FILE: src/LeichtFrame.Core/Memory/NullBitmap.cs =====
using System.Buffers;
using System.Runtime.CompilerServices;

namespace LeichtFrame.Core
{
    /// <summary>
    /// A memory-efficient bitset used to track null values in nullable columns.
    /// Uses 1 bit per row, resulting in very low memory overhead (approx. 1.5% of an integer array).
    /// </summary>
    public class NullBitmap : IDisposable
    {
        private ulong[] _buffer;
        private int _capacity;

        /// <summary>
        /// Initializes a new instance of the <see cref="NullBitmap"/> class.
        /// </summary>
        /// <param name="capacity">The initial number of bits (rows) to support.</param>
        public NullBitmap(int capacity)
        {
            _capacity = capacity;
            // Calculate how many ulongs are needed to cover 'capacity' bits
            int ulongCount = (capacity + 63) >> 6;
            _buffer = ArrayPool<ulong>.Shared.Rent(ulongCount);

            // IMPORTANT: Arrays from ArrayPool are "dirty", we need to clear them.
            Array.Clear(_buffer, 0, ulongCount);
        }

        /// <summary>
        /// Checks if the bit at the specified index is set (meaning the value is null).
        /// </summary>
        /// <param name="index">The zero-based index to check.</param>
        /// <returns><c>true</c> if the bit is set (null); otherwise, <c>false</c>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsNull(int index)
        {
            // index >> 6 is identical to index / 64, but often faster
            // index & 63 is identical to index % 64
            return (_buffer[index >> 6] & (1UL << (index & 63))) != 0;
        }

        /// <summary>
        /// Sets the bit at the specified index (marking the value as null).
        /// </summary>
        /// <param name="index">The zero-based index to set.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SetNull(int index)
        {
            _buffer[index >> 6] |= (1UL << (index & 63));
        }

        /// <summary>
        /// Clears the bit at the specified index (marking the value as not null).
        /// </summary>
        /// <param name="index">The zero-based index to clear.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SetNotNull(int index)
        {
            _buffer[index >> 6] &= ~(1UL << (index & 63));
        }

        /// <summary>
        /// Resizes the internal buffer to accommodate at least the specified number of bits.
        /// Preserves existing data.
        /// </summary>
        /// <param name="newCapacity">The new minimum capacity.</param>
        public void Resize(int newCapacity)
        {
            if (newCapacity <= _capacity) return;

            int oldUlongCount = (_capacity + 63) >> 6;
            int newUlongCount = (newCapacity + 63) >> 6;

            // Case 1: Buffer too small -> New buffer needed
            if (newUlongCount > _buffer.Length)
            {
                var newBuffer = ArrayPool<ulong>.Shared.Rent(newUlongCount);

                // Save old data
                Array.Copy(_buffer, newBuffer, oldUlongCount);

                // Clear the new area in the new buffer
                Array.Clear(newBuffer, oldUlongCount, newUlongCount - oldUlongCount);

                ArrayPool<ulong>.Shared.Return(_buffer);
                _buffer = newBuffer;
            }
            // Case 2: Buffer still large enough, but we now use more "words" from it
            else if (newUlongCount > oldUlongCount)
            {
                // Clear the "freshly uncovered" area in the existing dirty buffer
                Array.Clear(_buffer, oldUlongCount, newUlongCount - oldUlongCount);
            }

            _capacity = newCapacity;
        }

        /// <inheritdoc />
        public void Dispose()
        {
            if (_buffer != null)
            {
                ArrayPool<ulong>.Shared.Return(_buffer);
                _buffer = null!;
            }
        }
    }
}
===== FILE: src/LeichtFrame.Examples/LeichtFrame.Examples.csproj =====
Ôªø<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsPackable>false</IsPackable>
    <GenerateDocumentationFile>false</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);CS1591</NoWarn>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\LeichtFrame.Core\LeichtFrame.Core.csproj" />
    <ProjectReference Include="..\LeichtFrame.IO\LeichtFrame.IO.csproj" />
  </ItemGroup>

</Project>
===== FILE: src/LeichtFrame.Examples/Program.cs =====
Ôªøusing System.Text;
using LeichtFrame.Core;
using LeichtFrame.IO;

Console.WriteLine("=========================================================");
Console.WriteLine("   üöÄ LeichtFrame - End-to-End Data Pipeline Demo");
Console.WriteLine("=========================================================");

// ---------------------------------------------------------
// 1. SETUP: Simulate Messy Input Data (CSV)
// ---------------------------------------------------------
string rawCsvData =
@"TransactionId,Department,SalesAmount,IsRefund
1,Sales,50.00,false
2,IT,120.50,false
3,,0.00,false
4,Sales,300.00,true
5,HR,45.00,false
6,Sales,15.50,false
7,,90.00,false
8,IT,200.00,false";

Console.WriteLine("\n[1] Generating simulated CSV data stream...");
using var memoryStream = new MemoryStream(Encoding.UTF8.GetBytes(rawCsvData));

// ---------------------------------------------------------
// 2. DEFINE SCHEMA (The "Gold Standard" Way via POCO)
// ---------------------------------------------------------
// Instead of manually building ColumnDefinitions, we simply use a class.
// This ensures type safety and clean code.
// ---------------------------------------------------------
var df = CsvReader.Read<TransactionData>(memoryStream);

Console.WriteLine($"[2] Read CSV into DataFrame. Loaded {df.RowCount} rows.");
Console.WriteLine("    Raw Data Preview:");
Console.WriteLine(df.Inspect());

// ---------------------------------------------------------
// 3. CLEANING (Filter)
// ---------------------------------------------------------
Console.WriteLine("[3] Cleaning Data (Removing missing Departments & Refunds)...");

var cleanedDf = df.Where(row =>
{
    // High-performance access via generic Get<T>
    string dept = row.Get<string>("Department");
    bool isRefund = row.Get<bool>("IsRefund");

    // Keep only if Department exists AND it's not a refund
    return !string.IsNullOrEmpty(dept) && !isRefund;
});

Console.WriteLine($"    Cleaned Data: {cleanedDf.RowCount} rows remaining.");
Console.WriteLine(cleanedDf.Inspect());

// ---------------------------------------------------------
// 4. AGGREGATION (GroupBy & Sum)
// ---------------------------------------------------------
Console.WriteLine("[4] Aggregating: Total Sales by Department...");

var reportDf = cleanedDf.GroupBy("Department").Sum("SalesAmount");

Console.WriteLine("    Report Result:");
Console.WriteLine(reportDf.Inspect());

// ---------------------------------------------------------
// 5. EXPORT (Parquet)
// ---------------------------------------------------------
string outputPath = "sales_report.parquet";
Console.WriteLine($"[5] Exporting Report to Parquet: '{outputPath}'...");

if (File.Exists(outputPath)) File.Delete(outputPath);
reportDf.WriteParquet(outputPath);

Console.WriteLine("‚úÖ Done! Pipeline executed successfully.");
Console.WriteLine("=========================================================");

// ---------------------------------------------------------
// POCO Definition
// ---------------------------------------------------------
public class TransactionData
{
    public int TransactionId { get; set; }

    // Nullable because input data might have missing values (e.g., "3,,0.00")
    public string? Department { get; set; }

    public double SalesAmount { get; set; }
    public bool IsRefund { get; set; }
}
===== FILE: src/LeichtFrame.IO/Arrow/ArrowConverter.cs =====
using Apache.Arrow;
using Apache.Arrow.Types;
using LeichtFrame.Core;

namespace LeichtFrame.IO
{
    /// <summary>
    /// Provides interoperability methods to convert between LeichtFrame <see cref="DataFrame"/> 
    /// and Apache Arrow <see cref="RecordBatch"/>.
    /// Enables integration with the broader data ecosystem (Spark, Python, etc.).
    /// </summary>
    public static class ArrowConverter
    {
        /// <summary>
        /// Converts an Apache Arrow RecordBatch into a LeichtFrame DataFrame.
        /// <para>
        /// <strong>Note:</strong> Currently performs a deep copy of the data (Phase 1 implementation).
        /// Zero-copy integration is planned for future releases.
        /// </para>
        /// </summary>
        /// <param name="batch">The source Apache Arrow RecordBatch.</param>
        /// <returns>A new <see cref="DataFrame"/> containing the data from the RecordBatch.</returns>
        /// <exception cref="ArgumentNullException">Thrown if the batch is null.</exception>
        /// <exception cref="NotSupportedException">Thrown if the Arrow data type is not supported by LeichtFrame.</exception>
        public static DataFrame ToDataFrame(RecordBatch batch)
        {
            if (batch == null) throw new ArgumentNullException(nameof(batch));

            var columns = new List<IColumn>(batch.ColumnCount);
            int rowCount = batch.Length;

            // Iterate over Arrow Arrays (Columns)
            foreach (var field in batch.Schema.FieldsList)
            {
                var arrowArray = batch.Column(field.Name);

                // We use the name from the schema
                string name = field.Name;

                // Conversion based on the Arrow type
                IColumn lfCol = ConvertArray(name, arrowArray, rowCount);
                columns.Add(lfCol);
            }

            return new DataFrame(columns);
        }

        /// <summary>
        /// Converts a LeichtFrame DataFrame into an Apache Arrow RecordBatch.
        /// </summary>
        /// <param name="df">The source DataFrame.</param>
        /// <returns>A new <see cref="RecordBatch"/> containing the data.</returns>
        /// <exception cref="ArgumentNullException">Thrown if the DataFrame is null.</exception>
        /// <exception cref="NotSupportedException">Thrown if a column type cannot be mapped to Arrow.</exception>
        public static RecordBatch ToRecordBatch(DataFrame df)
        {
            if (df == null) throw new ArgumentNullException(nameof(df));

            // 1. Build Arrow Schema
            var builder = new Schema.Builder();
            foreach (var col in df.Columns)
            {
                builder.Field(f => f.Name(col.Name).DataType(GetArrowType(col.DataType)).Nullable(col.IsNullable));
            }
            var arrowSchema = builder.Build();

            // 2. Build Arrow Arrays
            var arrowArrays = new List<IArrowArray>(df.ColumnCount);
            foreach (var col in df.Columns)
            {
                arrowArrays.Add(BuildArrowArray(col));
            }

            // 3. Create Batch
            return new RecordBatch(arrowSchema, arrowArrays, df.RowCount);
        }

        private static IArrowType GetArrowType(Type type)
        {
            if (type == typeof(int)) return Int32Type.Default;
            if (type == typeof(double)) return DoubleType.Default;
            if (type == typeof(bool)) return BooleanType.Default;
            if (type == typeof(string)) return StringType.Default;
            if (type == typeof(DateTime)) return TimestampType.Default;

            throw new NotSupportedException($"Type '{type.Name}' cannot be mapped to Arrow.");
        }

        private static IArrowArray BuildArrowArray(IColumn col)
        {
            if (col is IntColumn ic)
            {
                var builder = new Int32Array.Builder();
                for (int i = 0; i < ic.Length; i++)
                {
                    if (ic.IsNull(i)) builder.AppendNull();
                    else builder.Append(ic.Get(i));
                }
                return builder.Build();
            }

            if (col is DoubleColumn dc)
            {
                var builder = new DoubleArray.Builder();
                for (int i = 0; i < dc.Length; i++)
                {
                    if (dc.IsNull(i)) builder.AppendNull();
                    else builder.Append(dc.Get(i));
                }
                return builder.Build();
            }

            if (col is StringColumn sc)
            {
                var builder = new StringArray.Builder();
                for (int i = 0; i < sc.Length; i++)
                {
                    // StringColumn handles nulls internally in Get() usually, but checking IsNull is safer/consistent
                    if (sc.IsNull(i)) builder.AppendNull();
                    else builder.Append(sc.Get(i));
                }
                return builder.Build();
            }

            if (col is BoolColumn bc)
            {
                var builder = new BooleanArray.Builder();
                for (int i = 0; i < bc.Length; i++)
                {
                    if (bc.IsNull(i)) builder.AppendNull();
                    else builder.Append(bc.Get(i));
                }
                return builder.Build();
            }

            if (col is DateTimeColumn dtc)
            {
                var builder = new TimestampArray.Builder();
                for (int i = 0; i < dtc.Length; i++)
                {
                    if (dtc.IsNull(i)) builder.AppendNull();
                    else
                    {
                        // Arrow prefers DateTimeOffset usually, but creates TimestampArray from it.
                        builder.Append(new DateTimeOffset(dtc.Get(i)));
                    }
                }
                return builder.Build();
            }

            throw new NotSupportedException($"Column type '{col.GetType().Name}' is not supported for Arrow export.");
        }

        private static IColumn ConvertArray(string name, IArrowArray array, int length)
        {
            // 1. Int32
            if (array is Int32Array intArray)
            {
                var col = new IntColumn(name, length, isNullable: true); // Arrow is usually nullable
                for (int i = 0; i < length; i++)
                {
                    if (intArray.IsNull(i)) col.Append(null);
                    else col.Append(intArray.GetValue(i));
                }
                return col;
            }

            // 2. Double
            if (array is DoubleArray doubleArray)
            {
                var col = new DoubleColumn(name, length, isNullable: true);
                for (int i = 0; i < length; i++)
                {
                    if (doubleArray.IsNull(i)) col.Append(null);
                    else col.Append(doubleArray.GetValue(i));
                }
                return col;
            }

            // 3. String
            if (array is StringArray stringArray)
            {
                var col = new StringColumn(name, length, isNullable: true);
                for (int i = 0; i < length; i++)
                {
                    // GetString returns null if null
                    col.Append(stringArray.GetString(i));
                }
                return col;
            }

            // 4. Bool
            if (array is BooleanArray boolArray)
            {
                var col = new BoolColumn(name, length, isNullable: true);
                for (int i = 0; i < length; i++)
                {
                    if (boolArray.IsNull(i)) col.Append(null);
                    else col.Append(boolArray.GetValue(i));
                }
                return col;
            }

            // 5. Date/Timestamp (Arrow has many time types, we support basic Timestamp here)
            if (array is TimestampArray tsArray)
            {
                var col = new DateTimeColumn(name, length, isNullable: true);
                for (int i = 0; i < length; i++)
                {
                    if (tsArray.IsNull(i)) col.Append(null);
                    else
                    {
                        // Arrow Timestamp is usually DateTimeOffset, we take DateTime
                        col.Append(tsArray.GetTimestamp(i)?.DateTime);
                    }
                }
                return col;
            }

            // Fallback for Date32 (Common in Parquet/Arrow)
            if (array is Date32Array date32Array)
            {
                var col = new DateTimeColumn(name, length, isNullable: true);
                for (int i = 0; i < length; i++)
                {
                    if (date32Array.IsNull(i)) col.Append(null);
                    else col.Append(date32Array.GetDateTime(i));
                }
                return col;
            }

            throw new NotSupportedException($"Arrow array type '{array.GetType().Name}' is not supported yet.");
        }
    }
}
===== FILE: src/LeichtFrame.IO/Arrow/ArrowExtensions.cs =====
using Apache.Arrow;
using LeichtFrame.Core;

namespace LeichtFrame.IO
{
    /// <summary>
    /// Provides extension methods for seamless integration with Apache Arrow.
    /// Allows converting <see cref="RecordBatch"/> to <see cref="DataFrame"/> and vice versa via fluent syntax.
    /// </summary>
    public static class ArrowExtensions
    {
        /// <summary>
        /// Converts an Apache Arrow <see cref="RecordBatch"/> directly into a LeichtFrame <see cref="DataFrame"/>.
        /// </summary>
        /// <param name="batch">The source Arrow RecordBatch.</param>
        /// <returns>A new DataFrame containing the data from the batch.</returns>
        /// <exception cref="ArgumentNullException">Thrown if the batch is null.</exception>
        public static DataFrame ToDataFrame(this RecordBatch batch)
        {
            return ArrowConverter.ToDataFrame(batch);
        }

        /// <summary>
        /// Converts the <see cref="DataFrame"/> into an Apache Arrow <see cref="RecordBatch"/>.
        /// Useful for passing data to other libraries like ML.NET, Spark, or Python (via interop).
        /// </summary>
        /// <param name="df">The source DataFrame.</param>
        /// <returns>A new Arrow RecordBatch representing the DataFrame.</returns>
        /// <exception cref="ArgumentNullException">Thrown if the DataFrame is null.</exception>
        public static RecordBatch ToArrow(this DataFrame df)
        {
            return ArrowConverter.ToRecordBatch(df);
        }
    }
}
===== FILE: src/LeichtFrame.IO/Csv/CsvReadOptions.cs =====
using System.Globalization;

namespace LeichtFrame.IO
{
    /// <summary>
    /// Configuration options for reading CSV files.
    /// </summary>
    public class CsvReadOptions
    {
        /// <summary>
        /// Gets or sets the delimiter used to separate fields. Default is ",".
        /// </summary>
        public string Separator { get; set; } = ",";

        /// <summary>
        /// Gets or sets a value indicating whether the first row of the CSV contains column headers. 
        /// Default is <c>true</c>.
        /// </summary>
        public bool HasHeader { get; set; } = true;

        /// <summary>
        /// Gets or sets the culture information used to parse numbers and dates. 
        /// Default is <see cref="CultureInfo.InvariantCulture"/> (dot decimal separator).
        /// </summary>
        public CultureInfo Culture { get; set; } = CultureInfo.InvariantCulture;

        /// <summary>
        /// Gets or sets a specific date format string (e.g. "yyyy-MM-dd").
        /// If null (default), the parser attempts to detect the format automatically based on the Culture.
        /// </summary>
        public string? DateFormat { get; set; } = null;
    }
}
===== FILE: src/LeichtFrame.IO/Csv/CsvReader.cs =====
using System.Globalization;
using LeichtFrame.Core;

namespace LeichtFrame.IO
{
    /// <summary>
    /// Provides high-performance methods to read CSV files into a <see cref="DataFrame"/>.
    /// Supports automatic schema inference and strongly-typed POCO mapping.
    /// </summary>
    public static class CsvReader
    {
        /// <summary>
        /// Reads a CSV file using a manually defined schema.
        /// Use this if you want to define columns dynamically at runtime.
        /// </summary>
        /// <param name="path">The file path to the CSV.</param>
        /// <param name="schema">The schema definition containing column names and types.</param>
        /// <param name="options">Optional CSV parsing options (separator, culture).</param>
        /// <returns>A populated <see cref="DataFrame"/>.</returns>
        public static DataFrame Read(string path, DataFrameSchema schema, CsvReadOptions? options = null)
        {
            using var stream = File.OpenRead(path);
            return Read(stream, schema, options);
        }


        /// <summary>
        /// Reads a CSV from a stream using a manually defined schema.
        /// </summary>
        /// <param name="stream">The input stream containing CSV data.</param>
        /// <param name="schema">The schema definition containing column names and types.</param>
        /// <param name="options">Optional CSV parsing options.</param>
        /// <returns>A populated <see cref="DataFrame"/>.</returns>
        public static DataFrame Read(Stream stream, DataFrameSchema schema, CsvReadOptions? options = null)
        {
            options ??= new CsvReadOptions();
            using var reader = new StreamReader(stream);

            // 1. Setup DataFrame
            var df = DataFrame.Create(schema, capacity: 100);

            // Cache Columns
            var columns = new IColumn[df.ColumnCount];
            for (int i = 0; i < df.ColumnCount; i++)
            {
                columns[i] = df.Columns[i];
            }

            // 2. Header Handling
            if (options.HasHeader)
            {
                reader.ReadLine();
            }

            // 3. Read Loop
            string? line;
            char[] sep = options.Separator.ToCharArray();

            while ((line = reader.ReadLine()) != null)
            {
                // FIX: Statt line.Split(sep) nutzen wir unseren Smart Splitter
                var parts = SplitCsvLine(line, options.Separator[0]); // Annahme: Separator ist 1 Char

                if (parts.Length < columns.Length) continue;

                for (int i = 0; i < columns.Length; i++)
                {
                    ParseAndAppend(columns[i], parts[i], options);
                }
            }

            return df;
        }

        private static void ParseAndAppend(IColumn col, string raw, CsvReadOptions options)
        {
            // Trim whitespace for numbers/dates is usually safer
            // raw = raw.Trim(); // Optional, depends on strictness

            // Handle Nulls
            if (string.IsNullOrEmpty(raw))
            {
                if (col is IntColumn ic) ic.Append(null);
                else if (col is DoubleColumn dc) dc.Append(null);
                else if (col is StringColumn sc) sc.Append(null);
                else if (col is BoolColumn bc) bc.Append(null);
                else if (col is DateTimeColumn dtc) dtc.Append(null);
                else throw new NotSupportedException($"Unknown column type: {col.GetType().Name}");
                return;
            }

            // Parse Values
            if (col is IntColumn iCol)
            {
                iCol.Append(int.Parse(raw, options.Culture));
            }
            else if (col is DoubleColumn dCol)
            {
                dCol.Append(double.Parse(raw, options.Culture));
            }
            else if (col is StringColumn sCol)
            {
                sCol.Append(raw);
            }
            else if (col is BoolColumn bCol)
            {
                if (bool.TryParse(raw, out bool bResult)) bCol.Append(bResult);
                else bCol.Append(raw == "1");
            }
            else if (col is DateTimeColumn dtCol)
            {
                if (options.DateFormat != null)
                    dtCol.Append(DateTime.ParseExact(raw, options.DateFormat, options.Culture));
                else
                    dtCol.Append(DateTime.Parse(raw, options.Culture));
            }
        }

        /// <summary>
        /// Splits a CSV line respecting quotes (RFC 4180).
        /// </summary>
        private static string[] SplitCsvLine(string line, char separator)
        {
            var values = new System.Collections.Generic.List<string>();
            int start = 0;
            bool inQuotes = false;

            for (int i = 0; i < line.Length; i++)
            {
                char c = line[i];

                if (c == '\"')
                {
                    inQuotes = !inQuotes; // Toggle Status
                }
                else if (c == separator && !inQuotes)
                {
                    // Trennzeichen gefunden (und nicht innerhalb von Quotes)
                    values.Add(Unescape(line.Substring(start, i - start)));
                    start = i + 1;
                }
            }

            // Letzten Wert hinzuf√ºgen
            if (start <= line.Length)
            {
                values.Add(Unescape(line.Substring(start)));
            }

            return values.ToArray();
        }

        /// <summary>
        /// Removes surrounding quotes and handles double-quote escaping.
        /// </summary>
        private static string Unescape(string value)
        {
            if (string.IsNullOrEmpty(value)) return value;

            // 1. Anf√ºhrungszeichen entfernen, falls vorhanden
            if (value.StartsWith("\"") && value.EndsWith("\"") && value.Length >= 2)
            {
                value = value.Substring(1, value.Length - 2);

                // 2. Doppelte Quotes ("") zu einem (") machen
                return value.Replace("\"\"", "\"");
            }

            return value;
        }

        /// <summary>
        /// Scans the CSV file to infer the schema (column names and types).
        /// </summary>
        /// <param name="path">Path to the CSV file.</param>
        /// <param name="options">Read options (separator, culture).</param>
        /// <param name="sampleRows">Number of rows to scan for type detection.</param>
        /// <returns>The inferred DataFrameSchema.</returns>
        public static DataFrameSchema InferSchema(string path, CsvReadOptions? options = null, int sampleRows = 100)
        {
            options ??= new CsvReadOptions();
            using var reader = new StreamReader(File.OpenRead(path));

            string? line = reader.ReadLine();
            if (line == null) throw new IOException("File is empty.");

            // 1. Determine Column Names
            string[] headers;
            char sep = options.Separator[0]; // MVP assumption: 1 char separator

            if (options.HasHeader)
            {
                headers = SplitCsvLine(line, sep);
            }
            else
            {
                var firstLineParts = SplitCsvLine(line, sep);
                headers = new string[firstLineParts.Length];
                for (int i = 0; i < headers.Length; i++) headers[i] = $"Column{i}";

                // Reset stream required? StreamReader is forward only.
                // If no header, the first line IS data. We must restart or parse first line manually.
                // For simplicity: close and reopen or use BaseStream.Seek if FileStream.
                // Easier for file path: Re-open reader or extract logic to scan lines.

                // FIX: Wenn kein Header, m√ºssen wir die Datei neu lesen, um Zeile 1 auch als Daten zu scannen.
                // Da wir StreamReader nicht resetten k√∂nnen (au√üer BaseStream.Position = 0), schlie√üen wir kurz.
                reader.DiscardBufferedData();
                reader.BaseStream.Seek(0, SeekOrigin.Begin);
            }

            // 2. Init Types (Assumption: Everything is Unknown/Int initially)
            var colTypes = new Type[headers.Length];
            var colNullable = new bool[headers.Length];

            // Wir lesen N Zeilen
            int readCount = 0;
            while (readCount < sampleRows && (line = reader.ReadLine()) != null)
            {
                var parts = SplitCsvLine(line, sep);

                // Handle ragged lines (skip or adjust) - MVP: ignore short lines
                if (parts.Length < headers.Length) continue;

                for (int i = 0; i < headers.Length; i++)
                {
                    string val = parts[i];

                    if (string.IsNullOrEmpty(val))
                    {
                        colNullable[i] = true;
                        continue;
                    }

                    // Determine type of this specific cell
                    Type cellType = DetectType(val, options);

                    // Merge with existing column type (Type Promotion)
                    colTypes[i] = MergeTypes(colTypes[i], cellType);
                }
                readCount++;
            }

            // 3. Build Schema
            var definitions = new System.Collections.Generic.List<ColumnDefinition>();
            for (int i = 0; i < headers.Length; i++)
            {
                // Fallback: If all were null or empty -> String
                Type finalType = colTypes[i] ?? typeof(string);
                definitions.Add(new ColumnDefinition(headers[i], finalType, colNullable[i]));
            }

            return new DataFrameSchema(definitions);
        }

        private static Type DetectType(string val, CsvReadOptions options)
        {
            if (int.TryParse(val, NumberStyles.Integer, options.Culture, out _)) return typeof(int);
            if (double.TryParse(val, NumberStyles.Float | NumberStyles.AllowThousands, options.Culture, out _)) return typeof(double);
            if (bool.TryParse(val, out _)) return typeof(bool);
            if (DateTime.TryParse(val, options.Culture, DateTimeStyles.None, out _)) return typeof(DateTime);

            return typeof(string);
        }

        private static Type MergeTypes(Type? current, Type newType)
        {
            if (current == null) return newType;
            if (current == newType) return current;

            // Type Promotion Rules

            // Int + Double -> Double
            if ((current == typeof(int) && newType == typeof(double)) ||
                (current == typeof(double) && newType == typeof(int)))
                return typeof(double);

            // Anything else mixed -> String (Safety fallback)
            // Example: Bool + Int -> String ("True", "123")
            // Example: Date + Double -> String
            return typeof(string);
        }

        /// <summary>
        /// Reads a CSV file, automatically inferring the schema from the header and content.
        /// </summary>
        public static DataFrame Read(string path, CsvReadOptions? options = null)
        {
            // 1. Schema raten
            var schema = InferSchema(path, options);

            // 2. Mit dem geratenen Schema lesen
            return Read(path, schema, options);
        }

        /// <summary>
        /// Reads a CSV file using a POCO class to define the schema strongly typed.
        /// </summary>
        public static DataFrame Read<T>(string path, CsvReadOptions? options = null)
        {
            var schema = DataFrameSchema.FromType<T>();
            return Read(path, schema, options);
        }

        /// <summary>
        /// Reads a CSV from a stream using a POCO class schema.
        /// </summary>
        /// <typeparam name="T">The POCO class defining the schema.</typeparam>
        /// <param name="stream">The input stream.</param>
        /// <param name="options">Optional CSV parsing options.</param>
        public static DataFrame Read<T>(Stream stream, CsvReadOptions? options = null)
        {
            var schema = DataFrameSchema.FromType<T>();
            return Read(stream, schema, options);
        }
    }
}
===== FILE: src/LeichtFrame.IO/Csv/CsvWriteOptions.cs =====
using System.Globalization;

namespace LeichtFrame.IO
{
    /// <summary>
    /// Configuration options for writing CSV files.
    /// </summary>
    public class CsvWriteOptions
    {
        /// <summary>
        /// Gets or sets the delimiter used to separate fields. Default is ",".
        /// </summary>
        public string Separator { get; set; } = ",";

        /// <summary>
        /// Gets or sets a value indicating whether to write column names as the first row. 
        /// Default is <c>true</c>.
        /// </summary>
        public bool WriteHeader { get; set; } = true;

        /// <summary>
        /// Gets or sets the culture information used to format numbers and dates.
        /// Default is <see cref="CultureInfo.InvariantCulture"/> (dot decimal separator) to ensure compatibility.
        /// </summary>
        public CultureInfo Culture { get; set; } = CultureInfo.InvariantCulture;

        /// <summary>
        /// Gets or sets the format string for <see cref="DateTime"/> values.
        /// Default is "o" (ISO 8601 round-trip pattern), which is the safest standard for machine processing.
        /// </summary>
        public string DateFormat { get; set; } = "o";

        /// <summary>
        /// Gets or sets the string representation for null values. 
        /// Default is an empty string.
        /// </summary>
        public string NullValue { get; set; } = "";
    }
}
===== FILE: src/LeichtFrame.IO/Csv/CsvWriter.cs =====
using System.Text;
using LeichtFrame.Core;

namespace LeichtFrame.IO
{
    /// <summary>
    /// Provides methods for writing <see cref="DataFrame"/> content to CSV format.
    /// Handles proper escaping (RFC 4180) and formatting based on configurable options.
    /// </summary>
    public static class CsvWriter
    {
        /// <summary>
        /// Writes the DataFrame to a CSV file at the specified path.
        /// Overwrites the file if it already exists.
        /// </summary>
        /// <param name="df">The DataFrame to write.</param>
        /// <param name="path">The full file path.</param>
        /// <param name="options">Optional formatting options (separator, date format, etc.).</param>
        public static void Write(DataFrame df, string path, CsvWriteOptions? options = null)
        {
            // File.Create overrides existing files
            using var stream = File.Create(path);
            Write(df, stream, options);
        }

        /// <summary>
        /// Writes the DataFrame to a stream in CSV format.
        /// </summary>
        /// <param name="df">The DataFrame to write.</param>
        /// <param name="stream">The output stream (must be writable).</param>
        /// <param name="options">Optional formatting options.</param>
        public static void Write(DataFrame df, Stream stream, CsvWriteOptions? options = null)
        {
            options ??= new CsvWriteOptions();

            // UTF8 without BOM is the standard nowadays, let the stream decide or enforce it
            using var writer = new StreamWriter(stream, new UTF8Encoding(false), 1024, leaveOpen: true);

            // 1. Write Header
            if (options.WriteHeader)
            {
                // Uses the API from B.5.2
                var headers = df.GetColumnNames();
                writer.WriteLine(string.Join(options.Separator, headers));
            }

            // 2. Write Rows
            var sb = new StringBuilder();

            for (int i = 0; i < df.RowCount; i++)
            {
                sb.Clear();
                for (int c = 0; c < df.ColumnCount; c++)
                {
                    if (c > 0) sb.Append(options.Separator);

                    var col = df[c];
                    // Untyped access (GetValue) is okay here since IO is the bottleneck anyway
                    object? val = col.GetValue(i);

                    string valStr = FormatValue(val, options);

                    // CSV Escaping (RFC 4180): 
                    // If separator, quote, or newline are present -> enclose text in quotes
                    if (NeedsEscaping(valStr, options.Separator))
                    {
                        // Escape double quotes (" -> "")
                        valStr = "\"" + valStr.Replace("\"", "\"\"") + "\"";
                    }

                    sb.Append(valStr);
                }
                writer.WriteLine(sb.ToString());
            }

            writer.Flush();
        }

        private static bool NeedsEscaping(string val, string separator)
        {
            // Performance check: Contains any of the critical characters?
            return val.Contains(separator) || val.Contains("\"") || val.Contains("\n") || val.Contains("\r");
        }

        private static string FormatValue(object? val, CsvWriteOptions options)
        {
            if (val == null) return options.NullValue;

            if (val is DateTime dt)
            {
                return dt.ToString(options.DateFormat, options.Culture);
            }
            if (val is bool b)
            {
                // Lowercase (true/false) or C# standard (True/False)? 
                // C# ToString() produces "True", JSON/JS prefers "true". We stick to C# standard for consistency.
                return b.ToString(options.Culture);
            }
            if (val is IFormattable formattable)
            {
                return formattable.ToString(null, options.Culture);
            }

            return val.ToString() ?? "";
        }
    }
}
===== FILE: src/LeichtFrame.IO/Csv/DataFrameCsvExtensions.cs =====
using System.Globalization;
using System.Text;
using LeichtFrame.Core;

namespace LeichtFrame.IO
{
    /// <summary>
    /// Provides extension methods for importing and exporting <see cref="DataFrame"/> objects via CSV.
    /// </summary>
    public static class DataFrameCsvExtensions
    {
        // =========================================================
        // WRITE EXTENSIONS (Export)
        // =========================================================

        /// <summary>
        /// Writes the DataFrame to a CSV file at the specified path.
        /// </summary>
        /// <param name="df">The source DataFrame.</param>
        /// <param name="path">The full path to the output file. Will be overwritten if it exists.</param>
        /// <param name="options">Optional configuration for writing (separator, date format, etc.).</param>
        public static void WriteCsv(this DataFrame df, string path, CsvWriteOptions? options = null)
        {
            CsvWriter.Write(df, path, options);
        }

        /// <summary>
        /// Writes the DataFrame to a stream in CSV format.
        /// </summary>
        /// <param name="df">The source DataFrame.</param>
        /// <param name="stream">The output stream.</param>
        /// <param name="options">Optional configuration for writing.</param>
        public static void WriteCsv(this DataFrame df, Stream stream, CsvWriteOptions? options = null)
        {
            CsvWriter.Write(df, stream, options);
        }

        // =========================================================
        // READ EXTENSIONS (Import)
        // =========================================================

        /// <summary>
        /// Reads a CSV file from a given path using a specific schema.
        /// </summary>
        /// <param name="path">The file path to the CSV.</param>
        /// <param name="schema">The schema definition describing column names and types.</param>
        /// <param name="hasHeader">Indicates if the first row contains column headers.</param>
        /// <param name="separator">The character used to separate fields.</param>
        /// <returns>A populated <see cref="DataFrame"/>.</returns>
        public static DataFrame ReadCsv(string path, DataFrameSchema schema, bool hasHeader = true, char separator = ',')
        {
            using var stream = File.OpenRead(path);
            return ReadCsv(stream, schema, hasHeader, separator);
        }

        /// <summary>
        /// Reads a CSV from a stream using a specific schema.
        /// </summary>
        /// <param name="stream">The input stream containing CSV data.</param>
        /// <param name="schema">The schema definition describing column names and types.</param>
        /// <param name="hasHeader">Indicates if the first row contains column headers.</param>
        /// <param name="separator">The character used to separate fields.</param>
        /// <returns>A populated <see cref="DataFrame"/>.</returns>
        /// <exception cref="ArgumentNullException">Thrown if stream or schema is null.</exception>
        public static DataFrame ReadCsv(Stream stream, DataFrameSchema schema, bool hasHeader = true, char separator = ',')
        {
            if (stream == null) throw new ArgumentNullException(nameof(stream));
            if (schema == null) throw new ArgumentNullException(nameof(schema));

            // Estimate row count roughly to minimize resizing (Performance optimization).
            // Assumption: approx. 100 bytes per row. Better than starting at capacity 0.
            int estimatedRows = (int)(stream.Length / 100);
            if (estimatedRows < 16) estimatedRows = 16;

            // 1. Create DataFrame (with schema and estimated capacity).
            var df = DataFrame.Create(schema, estimatedRows);

            using var reader = new StreamReader(stream, Encoding.UTF8, detectEncodingFromByteOrderMarks: true, bufferSize: 65536);

            // 2. Skip Header if present
            if (hasHeader && !reader.EndOfStream)
            {
                reader.ReadLine();
            }

            // Cache columns to avoid dictionary lookup per row
            var columns = df.Columns;
            int colCount = columns.Count;

            // 3. Read and parse lines
            while (!reader.EndOfStream)
            {
                var line = reader.ReadLine();
                if (string.IsNullOrWhiteSpace(line)) continue;

                var parts = line.Split(separator);

                // Strict schema check: Ignore lines with fewer columns than schema
                if (parts.Length < colCount) continue;

                for (int i = 0; i < colCount; i++)
                {
                    string rawValue = parts[i];
                    var col = columns[i];

                    try
                    {
                        ParseAndAppend(col, rawValue);
                    }
                    catch
                    {
                        // Fallback on parse error: Append null or default
                        if (col.IsNullable)
                        {
                            col.AppendObject(null);
                        }
                        else
                        {
                            col.AppendObject(GetDefault(col.DataType));
                        }
                    }
                }
            }

            return df;
        }

        // =========================================================
        // INTERNAL HELPERS
        // =========================================================

        private static void ParseAndAppend(IColumn col, string rawValue)
        {
            Type targetType = col.DataType;

            // Handle Nulls
            if (string.IsNullOrEmpty(rawValue))
            {
                if (col.IsNullable)
                {
                    col.AppendObject(null);
                    return;
                }
            }

            // Parsing Logic (Always use InvariantCulture for data interchange!)
            if (targetType == typeof(int))
            {
                if (int.TryParse(rawValue, NumberStyles.Any, CultureInfo.InvariantCulture, out int result))
                    col.AppendObject(result);
                else
                    col.AppendObject(GetDefault(typeof(int))); // Fallback
            }
            else if (targetType == typeof(double))
            {
                if (double.TryParse(rawValue, NumberStyles.Any, CultureInfo.InvariantCulture, out double result))
                    col.AppendObject(result);
                else
                    col.AppendObject(GetDefault(typeof(double)));
            }
            else if (targetType == typeof(bool))
            {
                if (bool.TryParse(rawValue, out bool result))
                    col.AppendObject(result);
                else
                    col.AppendObject(false);
            }
            else if (targetType == typeof(string))
            {
                col.AppendObject(rawValue);
            }
            else if (targetType == typeof(DateTime))
            {
                if (DateTime.TryParse(rawValue, CultureInfo.InvariantCulture, DateTimeStyles.None, out DateTime result))
                    col.AppendObject(result);
                else
                    col.AppendObject(GetDefault(typeof(DateTime)));
            }
            else
            {
                // General Fallback
                try
                {
                    col.AppendObject(Convert.ChangeType(rawValue, targetType, CultureInfo.InvariantCulture));
                }
                catch
                {
                    col.AppendObject(GetDefault(targetType));
                }
            }
        }

        private static object? GetDefault(Type type)
        {
            if (type.IsValueType)
            {
                return Activator.CreateInstance(type);
            }
            return null;
        }
    }
}
===== FILE: src/LeichtFrame.IO/LeichtFrame.IO.csproj =====
Ôªø<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <ProjectReference Include="..\LeichtFrame.Core\LeichtFrame.Core.csproj" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Apache.Arrow" Version="22.1.0" />
    <PackageReference Include="Parquet.Net" Version="5.4.0" />
  </ItemGroup>

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>

===== FILE: src/LeichtFrame.IO/Parquet/DataFrameParquetExtensions.cs =====
using LeichtFrame.Core;

namespace LeichtFrame.IO
{
    /// <summary>
    /// Provides extension methods for exporting <see cref="DataFrame"/> objects to Apache Parquet format.
    /// </summary>
    public static class DataFrameParquetExtensions
    {
        /// <summary>
        /// Writes the DataFrame to a Parquet file at the specified path.
        /// </summary>
        /// <param name="df">The source DataFrame to export.</param>
        /// <param name="path">The file path where the Parquet file will be created or overwritten.</param>
        public static void WriteParquet(this DataFrame df, string path)
        {
            ParquetWriter.Write(df, path);
        }

        /// <summary>
        /// Writes the DataFrame to a stream in Parquet format.
        /// </summary>
        /// <param name="df">The source DataFrame to export.</param>
        /// <param name="stream">The writable output stream.</param>
        public static void WriteParquet(this DataFrame df, Stream stream)
        {
            ParquetWriter.Write(df, stream);
        }

        /// <summary>
        /// Writes the DataFrame to a stream asynchronously in Parquet format.
        /// Recommended for Web APIs to avoid blocking threads during I/O.
        /// </summary>
        /// <param name="df">The source DataFrame to export.</param>
        /// <param name="stream">The writable output stream.</param>
        /// <returns>A task that represents the asynchronous write operation.</returns>
        public static Task WriteParquetAsync(this DataFrame df, Stream stream)
        {
            return ParquetWriter.WriteAsync(df, stream);
        }
    }
}
===== FILE: src/LeichtFrame.IO/Parquet/ParquetReader.cs =====
using LeichtFrame.Core;
using Parquet.Schema;

namespace LeichtFrame.IO
{
    /// <summary>
    /// Provides high-performance methods to read Apache Parquet files into a <see cref="DataFrame"/>.
    /// Automatically maps Parquet schema types to LeichtFrame column types.
    /// </summary>
    public static class ParquetReader
    {
        /// <summary>
        /// Reads a Parquet file from the specified file path.
        /// </summary>
        /// <param name="path">The full path to the Parquet file.</param>
        /// <returns>A populated <see cref="DataFrame"/> containing the data.</returns>
        public static DataFrame Read(string path)
        {
            using var stream = File.OpenRead(path);
            return Read(stream);
        }

        /// <summary>
        /// Reads a Parquet file from a stream synchronously.
        /// </summary>
        /// <param name="stream">The input stream containing Parquet data.</param>
        /// <returns>A populated <see cref="DataFrame"/>.</returns>
        public static DataFrame Read(Stream stream)
        {
            // Synchronous Wrapper for the Async method
            return ReadAsync(stream).GetAwaiter().GetResult();
        }

        /// <summary>
        /// Reads a Parquet file from a stream asynchronously.
        /// Recommended for I/O-bound operations in Web APIs to avoid blocking threads.
        /// </summary>
        /// <param name="stream">The input stream containing Parquet data.</param>
        /// <returns>A task that represents the asynchronous read operation, containing the resulting <see cref="DataFrame"/>.</returns>
        public static async Task<DataFrame> ReadAsync(Stream stream)
        {
            using var reader = await Parquet.ParquetReader.CreateAsync(stream);

            // 1. Schema Mapping (Parquet -> LeichtFrame)
            var dataFields = reader.Schema.GetDataFields();
            var colDefs = dataFields.Select(f => MapToColumnDefinition(f));
            var schema = new DataFrameSchema(colDefs);

            // 2. Create DataFrame (RowCount is known in metadata header!)
            // Parquet stores rows per RowGroup. We sum or take capacity.
            // For simplicity, we start empty and let Append work.
            var df = DataFrame.Create(schema, capacity: 1000); // Tuning option for later

            // 3. Read Data (RowGroup by RowGroup)
            for (int i = 0; i < reader.RowGroupCount; i++)
            {
                using var groupReader = reader.OpenRowGroupReader(i);

                foreach (var field in dataFields)
                {
                    var column = df[field.Name];

                    // Reads the entire column of this RowGroup as an array
                    var parquetColumn = await groupReader.ReadColumnAsync(field);

                    // 4. Copy Data to LeichtFrame Column
                    AppendData(column, parquetColumn.Data);
                }
            }

            return df;
        }

        private static ColumnDefinition MapToColumnDefinition(DataField field)
        {
            // Mapping Parquet Types -> .NET Types
            Type targetType = field.ClrNullableIfHasNullsType;

            // We want the core type for LeichtFrame (int instead of int?) + IsNullable flag
            Type coreType = Nullable.GetUnderlyingType(targetType) ?? targetType;
            bool isNullable = field.IsNullable || targetType.IsGenericType; // rough rule

            // Support Check
            if (coreType != typeof(int) && coreType != typeof(double) &&
                coreType != typeof(string) && coreType != typeof(bool) &&
                coreType != typeof(DateTime))
            {
                // Fallback or Error? Parquet has many types (Decimal, Float...).
                // MVP: We throw an error for unsupported types.
                throw new NotSupportedException($"Parquet type '{coreType.Name}' for column '{field.Name}' is not supported yet.");
            }

            return new ColumnDefinition(field.Name, coreType, isNullable);
        }

        private static void AppendData(IColumn col, Array data)
        {
            // The array from Parquet.Net is typed (e.g., int[] or int?[])
            // We iterate and append.
            // Performance note: In phase 2, we could use low-level Array.Copy here,
            // if the types match exactly (zero-copy or bulk-copy).

            if (col is IntColumn ic)
            {
                foreach (var item in data) ic.Append((int?)item);
            }
            else if (col is DoubleColumn dc)
            {
                foreach (var item in data) dc.Append((double?)item);
            }
            else if (col is StringColumn sc)
            {
                foreach (var item in data) sc.Append((string?)item);
            }
            else if (col is BoolColumn bc)
            {
                foreach (var item in data) bc.Append((bool?)item);
            }
            else if (col is DateTimeColumn dtc)
            {
                foreach (var item in data) dtc.Append((DateTime?)item);
            }
        }
    }
}
===== FILE: src/LeichtFrame.IO/Parquet/ParquetWriter.cs =====
using LeichtFrame.Core;
using Parquet.Data;
using Parquet.Schema;

namespace LeichtFrame.IO
{
    /// <summary>
    /// Provides methods for writing <see cref="DataFrame"/> objects into Apache Parquet format.
    /// Handles schema mapping and efficient data conversion for storage.
    /// </summary>
    public static class ParquetWriter
    {
        /// <summary>
        /// Writes the DataFrame to a Parquet file at the specified path.
        /// If the file exists, it will be overwritten.
        /// </summary>
        /// <param name="df">The source DataFrame.</param>
        /// <param name="path">The output file path.</param>
        public static void Write(DataFrame df, string path)
        {
            // Allow overwrite
            using var stream = File.Create(path);
            Write(df, stream);
        }

        /// <summary>
        /// Writes the DataFrame to a stream in Parquet format synchronously.
        /// </summary>
        /// <param name="df">The source DataFrame.</param>
        /// <param name="stream">The writable output stream.</param>
        public static void Write(DataFrame df, Stream stream)
        {
            // Synchronous Wrapper
            WriteAsync(df, stream).GetAwaiter().GetResult();
        }

        /// <summary>
        /// Writes the DataFrame to a stream in Parquet format asynchronously.
        /// </summary>
        /// <param name="df">The source DataFrame.</param>
        /// <param name="stream">The writable output stream.</param>
        /// <returns>A task representing the asynchronous write operation.</returns>
        public static async Task WriteAsync(DataFrame df, Stream stream)
        {
            // 1. Schema Mapping (LeichtFrame -> Parquet)
            var dataFields = df.Schema.Columns.Select(MapToDataField).ToArray();
            var parquetSchema = new ParquetSchema(dataFields);

            // 2. Writer Setup
            using var writer = await Parquet.ParquetWriter.CreateAsync(parquetSchema, stream);

            // We write everything in one RowGroup (simplest solution for MVP)
            using var groupWriter = writer.CreateRowGroup();

            // 3. Column Data Conversion & Write
            for (int i = 0; i < df.ColumnCount; i++)
            {
                var col = df.Columns[i];
                var field = dataFields[i];

                // Data conversion (NullBitmap -> Nullable Array)
                Array data = ConvertToParquetArray(col);

                var dataColumn = new DataColumn(field, data);
                await groupWriter.WriteColumnAsync(dataColumn);
            }
        }

        private static DataField MapToDataField(ColumnDefinition def)
        {
            // Int -> Int32, Nullable handling via Type?
            Type t = def.DataType;
            if (def.IsNullable && t.IsValueType)
            {
                t = typeof(Nullable<>).MakeGenericType(t);
            }
            return new DataField(def.Name, t);
        }

        private static Array ConvertToParquetArray(IColumn col)
        {
            // Fast Path: If not nullable and primitive, we might be able to use the array directly?
            // Unfortunately, Values.Span does not return the array, and Parquet.Net requires an Array.
            // We usually have to copy to be safe (snapshot).

            if (col is IntColumn ic)
            {
                if (!ic.IsNullable) return ic.Values.ToArray(); // int[]

                // Nullable Conversion: int[] + bitmap -> int?[]
                var result = new int?[ic.Length];
                for (int i = 0; i < ic.Length; i++)
                    result[i] = ic.IsNull(i) ? null : ic.Get(i);
                return result;
            }

            if (col is DoubleColumn dc)
            {
                if (!dc.IsNullable) return dc.Values.ToArray();

                var result = new double?[dc.Length];
                for (int i = 0; i < dc.Length; i++)
                    result[i] = dc.IsNull(i) ? null : dc.Get(i);
                return result;
            }

            if (col is BoolColumn bc)
            {
                // BoolColumn is bit-packed internally. We need to unpack to bool[] or bool?[]
                if (!bc.IsNullable)
                {
                    var result = new bool[bc.Length];
                    for (int i = 0; i < bc.Length; i++) result[i] = bc.Get(i);
                    return result;
                }
                else
                {
                    var result = new bool?[bc.Length];
                    for (int i = 0; i < bc.Length; i++)
                        result[i] = bc.IsNull(i) ? null : bc.Get(i);
                    return result;
                }
            }

            if (col is StringColumn sc)
            {
                // String is already a reference type, we can use ToArray
                // (StringColumn stores nulls directly in the array)
                return sc.Values.ToArray();
            }

            if (col is DateTimeColumn dtc)
            {
                if (!dtc.IsNullable) return dtc.Values.ToArray();

                var result = new DateTime?[dtc.Length];
                for (int i = 0; i < dtc.Length; i++)
                    result[i] = dtc.IsNull(i) ? null : dtc.Get(i);
                return result;
            }

            throw new NotSupportedException($"Writing column type '{col.DataType.Name}' to Parquet is not supported.");
        }
    }
}
===== FILE: tests/LeichtFrame.Core.Tests/Columns/BoolColumnTests.cs =====
namespace LeichtFrame.Core.Tests.Columns
{
    public class BoolColumnTests
    {
        [Fact]
        public void BitPacking_Works_Across_ByteBoundaries()
        {
            // Capacity 16 = 2 Bytes
            using var col = new BoolColumn("Bits", 16);

            // Set index 0, 7 (Byte 0 ends), 8 (Byte 1 starts)
            for (int i = 0; i < 10; i++) col.Append(false);

            col.SetValue(0, true);
            col.SetValue(7, true);
            col.SetValue(8, true);

            Assert.True(col.Get(0));
            Assert.True(col.Get(7));
            Assert.True(col.Get(8));

            Assert.False(col.Get(1));
            Assert.False(col.Get(6));
            Assert.False(col.Get(9));
        }

        [Fact]
        public void AnyTrue_And_AllTrue_Logic()
        {
            using var col = new BoolColumn("Logic", 100);

            // 1. Empty/All False
            col.Append(false);
            col.Append(false);
            Assert.False(col.AnyTrue());
            Assert.False(col.AllTrue());

            // 2. Set one true
            col.SetValue(0, true);
            Assert.True(col.AnyTrue());
            Assert.False(col.AllTrue());

            // 3. Set all true
            col.SetValue(1, true);
            Assert.True(col.AllTrue());
        }

        [Fact]
        public void Logic_Ignores_Nulls()
        {
            using var col = new BoolColumn("NullLogic", 10, isNullable: true);

            col.Append(true);
            col.Append((bool?)null); // Should be ignored

            Assert.True(col.AllTrue()); // True because the only valid value is true
            Assert.True(col.AnyTrue());

            col.Append(false);
            Assert.False(col.AllTrue()); // Now we have a false
        }

        [Fact]
        public void Values_Property_Throws_Exception()
        {
            using var col = new BoolColumn("NoSlice", 10);
            Assert.Throws<NotSupportedException>(() => _ = col.Values);
        }

        [Fact]
        public void Resizing_Preserves_Bits()
        {
            using var col = new BoolColumn("Resize", 8); // 1 Byte
            for (int i = 0; i < 8; i++) col.Append(true); // Fill byte with 1s (255)

            col.Append(false); // Trigger resize to 2nd byte

            Assert.Equal(9, col.Length);
            Assert.True(col.Get(0));
            Assert.True(col.Get(7));
            Assert.False(col.Get(8));
        }
    }
}
===== FILE: tests/LeichtFrame.Core.Tests/Columns/ColumnFactoryTests.cs =====
using LeichtFrame.Core;


public class ColumnFactoryTests
{
    [Fact]
    public void Create_WithIntType_ReturnsIntColumn()
    {
        var col = ColumnFactory.Create("age", typeof(int), capacity: 32);
        Assert.NotNull(col);
        Assert.IsType<IntColumn>(col);
        Assert.Equal("age", col.Name);
        Assert.Equal(typeof(int), col.DataType);
    }

    [Fact]
    public void Create_GenericInt_Returns_IColumnOfInt()
    {
        var col = ColumnFactory.Create<int>("age", capacity: 16);
        Assert.NotNull(col);
        Assert.IsAssignableFrom<IColumn<int>>(col);
        Assert.Equal("age", col.Name);
        Assert.Equal(typeof(int), col.DataType);
    }

    [Fact]
    public void Create_UnsupportedType_Throws()
    {
        Assert.Throws<NotSupportedException>(() =>
        {
            ColumnFactory.Create("obj", typeof(DateTimeOffset), capacity: 4);
        });
    }
}

===== FILE: tests/LeichtFrame.Core.Tests/Columns/ColumnTests.cs =====
using LeichtFrame.Core.Tests.Mocks;

namespace LeichtFrame.Core.Tests;

public class ColumnTests
{
    [Fact]
    public void Column_Should_Have_Correct_Metadata()
    {
        // Arrange
        var col = new SimpleMockColumn<int>("Age", 10);

        // Assert
        Assert.Equal("Age", col.Name);
        Assert.Equal(typeof(int), col.DataType);
        Assert.Equal(10, col.Length);
    }

    [Fact]
    public void Column_Should_Throw_On_Invalid_Name()
    {
        Assert.Throws<ArgumentException>(() => new SimpleMockColumn<int>("", 10));
        Assert.Throws<ArgumentException>(() => new SimpleMockColumn<int>(null!, 10));
    }

    [Fact]
    public void Column_Get_Set_Values_Work()
    {
        // Arrange
        var col = new SimpleMockColumn<int>("Id", 5);

        // Act
        col.SetValue(0, 42);
        col.SetValue(2, 100);

        // Assert
        Assert.Equal(42, col.Get(0));
        Assert.Equal(0, col.Get(1));
        Assert.Equal(100, col.Get(2));
    }

    [Fact]
    public void Column_Null_Handling_Works()
    {
        // Arrange
        var col = new SimpleMockColumn<string>("Names", 3);

        // Act
        col.SetValue(0, "Alice");
        col.SetNull(1);

        // Assert
        Assert.False(col.IsNull(0));
        Assert.True(col.IsNull(1));
    }
}
===== FILE: tests/LeichtFrame.Core.Tests/Columns/DateColumnTests.cs =====
namespace LeichtFrame.Core.Tests.Columns
{
    public class DateTimeColumnTests
    {
        [Fact]
        public void Basic_Roundtrip_Works()
        {
            using var col = new DateTimeColumn("Dates", 10);
            var now = DateTime.Now;
            var tomorrow = now.AddDays(1);

            col.Append(now);
            col.Append(tomorrow);

            Assert.Equal(2, col.Length);
            Assert.Equal(now, col.Get(0));
            Assert.Equal(tomorrow, col.Get(1));
        }

        [Fact]
        public void Nullable_Support_Works()
        {
            using var col = new DateTimeColumn("NullableDates", 10, isNullable: true);
            var now = DateTime.UtcNow;

            col.Append(now);
            col.Append((DateTime?)null);

            Assert.False(col.IsNull(0));
            Assert.True(col.IsNull(1));

            Assert.Equal(default(DateTime), col.Get(1));
        }

        [Fact]
        public void Resizing_Preserves_Data()
        {
            using var col = new DateTimeColumn("Resize", 2);
            col.Append(new DateTime(2023, 1, 1));
            col.Append(new DateTime(2023, 1, 2));
            col.Append(new DateTime(2023, 1, 3));

            Assert.Equal(3, col.Length);
            Assert.Equal(new DateTime(2023, 1, 3), col.Get(2));
        }

        [Fact]
        public void NonNullable_Throws_On_Null()
        {
            using var col = new DateTimeColumn("Strict", 5, isNullable: false);

            Assert.Throws<InvalidOperationException>(() => col.Append((DateTime?)null));

            col.Append(DateTime.Now);
            Assert.Throws<InvalidOperationException>(() => col.SetNull(0));
        }
    }
}
===== FILE: tests/LeichtFrame.Core.Tests/Columns/DoubleColumnTests.cs =====
namespace LeichtFrame.Core.Tests.Columns
{
    public class DoubleColumnTests
    {
        [Fact]
        public void Statistical_Helpers_Ignore_Nulls()
        {
            using var col = new DoubleColumn("Stats", 10, isNullable: true);
            col.Append(10.0);
            col.Append(20.0);
            col.Append((double?)null);
            col.Append(5.0);

            Assert.Equal(35.0, col.Sum());
            Assert.Equal(5.0, col.Min());
            Assert.Equal(20.0, col.Max());
        }

        [Fact]
        public void NaN_Distinction_Works()
        {
            // Requirement: NaN = actual NaN, Null = bitmap
            using var col = new DoubleColumn("NaNTest", 10, isNullable: true);

            col.Append(double.NaN);       // Mathematical NaN
            col.Append((double?)null);    // Logical Null

            // Index 0: Not Null, but value is NaN
            Assert.False(col.IsNull(0));
            Assert.True(double.IsNaN(col.Get(0)));

            // Index 1: Is Null
            Assert.True(col.IsNull(1));
        }

        [Fact]
        public void Aggregations_Work_On_NonNullable()
        {
            using var col = new DoubleColumn("Strict", 10, isNullable: false);
            col.Append(1.5);
            col.Append(2.5);

            Assert.Equal(4.0, col.Sum());
            Assert.Equal(1.5, col.Min());
            Assert.Equal(2.5, col.Max());
        }
    }
}
===== FILE: tests/LeichtFrame.Core.Tests/Columns/IntColumnTests.cs =====
namespace LeichtFrame.Core.Tests.Columns
{
    public class IntColumnTests
    {
        [Fact]
        public void Constructor_Sets_IsNullable_Correctly()
        {
            using var col1 = new IntColumn("A", 10, isNullable: false);
            using var col2 = new IntColumn("B", 10, isNullable: true);

            Assert.False(col1.IsNullable);
            Assert.True(col2.IsNullable);
        }

        [Fact]
        public void SetValue_And_GetValue_Work()
        {
            using var col = new IntColumn("Test", 10);
            col.Append(0);

            col.SetValue(0, 42);

            Assert.Equal(42, col.Get(0));
        }

        [Fact]
        public void Append_Resizes_Automatically()
        {
            using var col = new IntColumn("Test", capacity: 2);

            col.Append(1);
            col.Append(2);
            col.Append(3);

            Assert.Equal(3, col.Length);
            Assert.Equal(1, col.Get(0));
            Assert.Equal(3, col.Get(2));
        }

        [Fact]
        public void NonNullable_Column_Throws_On_SetNull()
        {
            using var col = new IntColumn("Strict", 10, isNullable: false);
            col.Append(1);

            Assert.Throws<InvalidOperationException>(() => col.SetNull(0));
        }

        [Fact]
        public void Nullable_Column_Can_Store_Nulls()
        {
            using var col = new IntColumn("Nullable", 10, isNullable: true);

            col.Append(10);
            col.Append((int?)null);

            Assert.False(col.IsNull(0));
            Assert.True(col.IsNull(1));

            Assert.Equal(0, col.Get(1));
        }

        [Fact]
        public void SetValue_Clears_Null_Flag()
        {
            using var col = new IntColumn("Nullable", 10, isNullable: true);
            col.Append((int?)null);
            Assert.True(col.IsNull(0));

            col.SetValue(0, 99);

            Assert.False(col.IsNull(0));
            Assert.Equal(99, col.Get(0));
        }

        [Fact]
        public void Dispose_Can_Be_Called_Safely()
        {
            var col = new IntColumn("Temp", 10);
            col.Append(1);

            col.Dispose();

            Assert.ThrowsAny<Exception>(() => col.Get(0));
        }
    }
}
===== FILE: tests/LeichtFrame.Core.Tests/Columns/SliceTests.cs =====
namespace LeichtFrame.Core.Tests.Columns
{
    public class SliceTests
    {
        [Fact]
        public void Slice_Returns_Correct_SubSet()
        {
            using var col = new IntColumn("Data", 10);
            col.Append(10);
            col.Append(20);
            col.Append(30);
            col.Append(40);
            col.Append(50);

            // Slice from index 1, length 3 -> [20, 30, 40]
            var slice = col.Slice(1, 3);

            Assert.Equal(3, slice.Length);
            Assert.Equal(20, slice.Span[0]);
            Assert.Equal(40, slice.Span[2]);
        }

        [Fact]
        public void Slice_Is_ZeroCopy()
        {
            // Slice operations do not allocate copies
            using var col = new IntColumn("ZeroCopy", 10);
            col.Append(100);
            col.Append(200);

            var slice = col.Slice(0, 2);

            // Modify ORIGINAL column
            col.SetValue(1, 999);

            // Verify SLICE sees the change (proof that it points to same memory)
            Assert.Equal(999, slice.Span[1]);
        }

        [Fact]
        public void Slice_Throws_On_Invalid_Bounds()
        {
            // Slice throws on invalid bounds
            using var col = new IntColumn("Bounds", 5);
            col.Append(1);
            col.Append(2);

            // Length is 2
            Assert.Throws<ArgumentOutOfRangeException>(() => col.Slice(0, 3)); // Too long
            Assert.Throws<ArgumentOutOfRangeException>(() => col.Slice(2, 1)); // Start at end
            Assert.Throws<ArgumentOutOfRangeException>(() => col.Slice(-1, 1)); // Negative start
        }

        [Fact]
        public void BoolColumn_Throws_NotSupported_On_Slice()
        {
            // BoolColumn special case
            using var col = new BoolColumn("Bools", 8);
            col.Append(true);

            Assert.Throws<NotSupportedException>(() => col.Slice(0, 1));
        }

        [Fact]
        public void StringColumn_Slice_Works()
        {
            using var col = new StringColumn("Strings", 5);
            col.Append("A");
            col.Append("B");
            col.Append("C");

            var slice = col.Slice(1, 1);
            Assert.Equal("B", slice.Span[0]);
        }
    }
}
===== FILE: tests/LeichtFrame.Core.Tests/Columns/StringColumnTests.cs =====
namespace LeichtFrame.Core.Tests.Columns
{
    public class StringColumnTests
    {
        [Fact]
        public void Basic_Append_Read()
        {
            using var col = new StringColumn("Names", 10);
            col.Append("Alice");
            col.Append("Bob");

            Assert.Equal(2, col.Length);
            Assert.Equal("Alice", col.Get(0));
            Assert.Equal("Bob", col.Get(1));
        }

        [Fact]
        public void Nullable_String_Works()
        {
            using var col = new StringColumn("Nullable", 10, isNullable: true);
            col.Append("Text");
            col.Append(null);

            Assert.False(col.IsNull(0));
            Assert.True(col.IsNull(1));
            Assert.Null(col.Get(1));
        }

        [Fact]
        public void Interning_Deduplicates_References()
        {
            // AC 3 Check
            using var col = new StringColumn("Interned", 10, useInterning: true);

            string s1 = new string(new char[] { 'A', 'B' }); // "AB" (new reference)
            string s2 = new string(new char[] { 'A', 'B' }); // "AB" (different reference)

            // Prove they are different objects initially
            Assert.False(object.ReferenceEquals(s1, s2));

            col.Append(s1);
            col.Append(s2);

            string? out1 = col.Get(0);
            string? out2 = col.Get(1);

            // After interning, they should point to the same object
            Assert.True(object.ReferenceEquals(out1, out2));
            Assert.Equal("AB", out1);
        }

        [Fact]
        public void Memory_Estimate_Returns_Plausible_Values()
        {
            // AC 4 Check
            using var col = new StringColumn("Mem", 100);
            col.Append("Hello"); // 5 chars * 2 = 10 bytes + overhead

            long est = col.EstimateMemoryUsage();

            // Minimal check: Array overhead + string content > 0
            Assert.True(est > 0);
            Assert.True(est > (10 + IntPtr.Size));
        }

        [Fact]
        public void Dispose_Clears_References()
        {
            // As we use ArrayPool, it is difficult to directly test 
            // if the array was cleared, as we lose the reference.
            // But we check that Dispose does not throw an exception.
            var col = new StringColumn("Temp", 10);
            col.Append("Foo");
            col.Dispose();
        }
    }
}
===== FILE: tests/LeichtFrame.Core.Tests/DataFrames/DataFrameFactoryTests.cs =====
namespace LeichtFrame.Core.Tests.DataFrameTests
{
    public class DataFrameFactoryTests
    {
        // POCO for Testing
        private class User
        {
            public int Id { get; set; }
            public string Name { get; set; } = null!;
            public double? Score { get; set; } // Nullable!
            public DateTime Created { get; set; }
            public bool IsActive { get; set; }
        }

        [Fact]
        public void FromObjects_Creates_Populated_DataFrame()
        {
            var now = DateTime.Now;
            var users = new List<User>
            {
                new User { Id = 1, Name = "Alice", Score = 99.5, Created = now, IsActive = true },
                new User { Id = 2, Name = "Bob", Score = null, Created = now.AddDays(1), IsActive = false }
            };

            var df = DataFrame.FromObjects(users);

            // Verify Structure
            Assert.Equal(2, df.RowCount);
            Assert.Equal(5, df.ColumnCount);

            // Check Schema
            Assert.Equal(typeof(int), df["Id"].DataType);
            Assert.Equal(typeof(double), df["Score"].DataType);
            Assert.True(df["Score"].IsNullable); // Should detect int? as nullable

            // Check Data
            Assert.Equal(1, df["Id"].Get<int>(0));
            Assert.Equal("Bob", df["Name"].Get<string>(1));

            // Check Nullable
            Assert.Equal(99.5, df["Score"].Get<double>(0));
            Assert.True(df["Score"].IsNull(1));
        }

        [Fact]
        public void FromObjects_Skips_Unsupported_Types()
        {
            var list = new[] { new { Id = 1, Complex = new object() } }; // Complex object should be skipped
            var df = DataFrame.FromObjects(list);

            Assert.Equal(1, df.ColumnCount);
            Assert.True(df.Schema.HasColumn("Id"));
            Assert.False(df.Schema.HasColumn("Complex"));
        }
    }
}
===== FILE: tests/LeichtFrame.Core.Tests/DataFrames/DataFrameTests.cs =====
namespace LeichtFrame.Core.Tests.DataFrames
{
    public class DataFrameTests
    {
        [Fact]
        public void Constructor_Builds_Schema_And_Sets_Counts()
        {
            using var col1 = new IntColumn("Id", 10);
            col1.Append(1);

            using var col2 = new StringColumn("Name", 10);
            col2.Append("A");

            var df = new DataFrame(new IColumn[] { col1, col2 });

            Assert.Equal(1, df.RowCount);
            Assert.Equal(2, df.ColumnCount);

            Assert.True(df.Schema.HasColumn("Id"));
            Assert.True(df.Schema.HasColumn("Name"));
            Assert.Equal(typeof(int), df.Schema.Columns[0].DataType);
        }

        [Fact]
        public void Constructor_Throws_On_Length_Mismatch()
        {
            using var col1 = new IntColumn("Id", 10);
            col1.Append(1); // Length 1

            using var col2 = new StringColumn("Name", 10);
            col2.Append("A");
            col2.Append("B"); // Length 2

            var ex = Assert.Throws<ArgumentException>(() => new DataFrame(new IColumn[] { col1, col2 }));

            Assert.Contains("mismatch", ex.Message);
        }

        [Fact]
        public void Dispose_Calls_Dispose_On_Columns()
        {
            // As we find it difficult to "look inside" the columns to check if they are disposed (without crashing),
            // we primarily test here that df.Dispose() does not throw any errors.
            // A real "was Dispose called" test would require mocks (Moq), 
            // but we use real classes here.

            var col = new IntColumn("Temp", 10);
            col.Append(1);

            var df = new DataFrame(new[] { col });

            df.Dispose();

            // Indirect proof: Accessing the column should now be unsafe 
            // (or in IntColumn in A.2 implementation: _data is null).
            Assert.ThrowsAny<Exception>(() => col.Get(0));
        }

        [Fact]
        public void Empty_DataFrame_Is_Valid()
        {
            var df = new DataFrame(new IColumn[0]);

            Assert.Equal(0, df.RowCount);
            Assert.Equal(0, df.ColumnCount);
            Assert.NotNull(df.Schema);
        }

        [Fact]
        public void Indexer_By_Int_Returns_Correct_Column()
        {
            using var col1 = new IntColumn("Col1", 5);
            using var col2 = new IntColumn("Col2", 5);
            var df = new DataFrame(new[] { col1, col2 });

            Assert.Same(col1, df[0]);
            Assert.Same(col2, df[1]);
        }

        [Fact]
        public void Indexer_By_Int_Throws_On_Invalid_Index()
        {
            var df = new DataFrame(new IColumn[0]);
            Assert.Throws<ArgumentOutOfRangeException>(() => df[0]);
        }

        [Fact]
        public void Indexer_By_Name_Returns_Correct_Column()
        {
            using var age = new IntColumn("Age", 5);
            using var name = new StringColumn("Name", 5);
            var df = new DataFrame(new IColumn[] { age, name });

            Assert.Same(age, df["Age"]);
            Assert.Same(name, df["Name"]);
        }

        [Fact]
        public void Indexer_By_Name_Throws_If_Missing()
        {
            using var col = new IntColumn("Data", 5);
            var df = new DataFrame(new[] { col });

            // Exception comes from Schema.GetColumnIndex
            Assert.Throws<ArgumentException>(() => df["Missing"]);
        }

        [Fact]
        public void TryGetColumn_Returns_False_If_Missing()
        {
            using var col = new IntColumn("Data", 5);
            var df = new DataFrame(new[] { col });

            bool found = df.TryGetColumn("Missing", out var result);

            Assert.False(found);
            Assert.Null(result);
        }

        [Fact]
        public void TryGetColumn_Returns_True_And_Column_If_Found()
        {
            using var col = new IntColumn("Data", 5);
            var df = new DataFrame(new[] { col });

            bool found = df.TryGetColumn("Data", out var result);

            Assert.True(found);
            Assert.Same(col, result);
        }

        [Fact]
        public void Create_Factory_Builds_Correct_Structure_From_Schema()
        {
            // 1. Define Schema (Blueprint)
            var schema = new DataFrameSchema(new[] {
                new ColumnDefinition("Id", typeof(int), IsNullable: false),
                new ColumnDefinition("Value", typeof(double), IsNullable: true),
                new ColumnDefinition("Label", typeof(string))
            });

            // 2. Create via Factory
            var df = DataFrame.Create(schema, capacity: 100);

            // 3. Verify Basics
            Assert.Equal(0, df.RowCount); // Must be empty
            Assert.Equal(3, df.ColumnCount);

            // 4. Verify Columns match Schema
            // Check ID
            var idCol = df["Id"];
            Assert.IsType<IntColumn>(idCol);
            Assert.False(idCol.IsNullable);

            // Check Value
            var valCol = df["Value"];
            Assert.IsType<DoubleColumn>(valCol);
            Assert.True(valCol.IsNullable);

            // 5. Verify Capacity (indirectly via functionality)
            ((IntColumn)idCol).Append(1);
            ((DoubleColumn)valCol).Append(null);
            ((StringColumn)df["Label"]).Append("Test");

            Assert.Equal(1, df.RowCount);
        }

        [Fact]
        public void ToString_Returns_Short_Summary()
        {
            var df = DataFrame.Create(new DataFrameSchema(new[] { new ColumnDefinition("A", typeof(int)) }), 5);
            // We do not add any data, capacity is 5, but length is 0 (because not appended)
            // Wait: Create allocates capacity, but length is 0. 
            // So we append 1 row.
            ((IntColumn)df["A"]).Append(100);

            Assert.Equal("DataFrame (1 rows, 1 columns)", df.ToString());
        }

        [Fact]
        public void Inspect_Formats_Output_Correctly()
        {
            // Arrange
            var schema = new DataFrameSchema(new[] {
                new ColumnDefinition("ID", typeof(int)),
                new ColumnDefinition("Name", typeof(string), IsNullable: true)
            });
            var df = DataFrame.Create(schema, 10);

            var idCol = (IntColumn)df["ID"];
            var nameCol = (StringColumn)df["Name"];

            idCol.Append(1); nameCol.Append("Alice");
            idCol.Append(2); nameCol.Append(null); // Test null display

            // Act
            string output = df.Inspect();

            // Assert
            // 1. Header & Types
            Assert.Contains("ID", output);
            Assert.Contains("Name", output);
            Assert.Contains("<Int32>", output);
            Assert.Contains("<String>", output);

            // 2. Data content
            Assert.Contains("1", output);
            Assert.Contains("Alice", output);
            Assert.Contains("2", output);
            Assert.Contains("null", output); // Should explicitly show "null"
        }

        [Fact]
        public void Schema_Inspection_API_Works()
        {
            // Arrange: DataFrame with known schema
            var schema = new DataFrameSchema(new[] {
                new ColumnDefinition("Age", typeof(int)),
                new ColumnDefinition("Name", typeof(string))
            });
            var df = DataFrame.Create(schema, 0);

            // 1. HasColumn
            Assert.True(df.HasColumn("Age"));
            Assert.True(df.HasColumn("Name"));
            Assert.False(df.HasColumn("Salary"));
            Assert.False(df.HasColumn(""));

            // 2. GetColumnNames
            var names = df.GetColumnNames();
            Assert.Equal(new[] { "Age", "Name" }, names);

            // 3. GetColumnType
            Assert.Equal(typeof(int), df.GetColumnType("Age"));
            Assert.Equal(typeof(string), df.GetColumnType("Name"));

            // Error Case: Missing Column
            Assert.Throws<ArgumentException>(() => df.GetColumnType("MissingCol"));
        }
    }
}
===== FILE: tests/LeichtFrame.Core.Tests/DataFrames/Operations/AggregationTests.cs =====
namespace LeichtFrame.Core.Tests.DataFrameTests
{
    public class AggregationTests
    {
        [Fact]
        public void Sum_Works_For_Int_And_Double()
        {
            var schema = new DataFrameSchema(new[] {
                new ColumnDefinition("Ints", typeof(int)),
                new ColumnDefinition("Doubles", typeof(double))
            });
            var df = DataFrame.Create(schema, 10);

            var intCol = (IntColumn)df["Ints"];
            var dblCol = (DoubleColumn)df["Doubles"];

            intCol.Append(10); intCol.Append(20);
            dblCol.Append(1.5); dblCol.Append(2.5);

            Assert.Equal(30.0, df.Sum("Ints"));
            Assert.Equal(4.0, df.Sum("Doubles"));
        }

        [Fact]
        public void Sum_Ignores_Nulls()
        {
            var schema = new DataFrameSchema(new[] {
                new ColumnDefinition("Val", typeof(int), IsNullable: true)
            });
            var df = DataFrame.Create(schema, 5);
            var col = (IntColumn)df["Val"];

            col.Append(10);
            col.Append(null);
            col.Append(20);

            // 10 + 0 + 20 = 30
            Assert.Equal(30.0, df.Sum("Val"));
        }

        [Fact]
        public void MinMax_Works_Correctly()
        {
            var schema = new DataFrameSchema(new[] { new ColumnDefinition("Vals", typeof(int)) });
            var df = DataFrame.Create(schema, 5);
            var col = (IntColumn)df["Vals"];

            col.Append(5);
            col.Append(100);
            col.Append(-10);

            Assert.Equal(-10.0, df.Min("Vals"));
            Assert.Equal(100.0, df.Max("Vals"));
        }

        [Fact]
        public void Mean_Calculates_Average_Correctly()
        {
            var schema = new DataFrameSchema(new[] { new ColumnDefinition("A", typeof(double)) });
            var df = DataFrame.Create(schema, 5);
            var col = (DoubleColumn)df["A"];

            col.Append(2.0);
            col.Append(4.0);

            Assert.Equal(3.0, df.Mean("A"));
        }

        [Fact]
        public void Aggregation_Throws_On_String()
        {
            var schema = new DataFrameSchema(new[] { new ColumnDefinition("Str", typeof(string)) });
            var df = DataFrame.Create(schema, 1);
            ((StringColumn)df["Str"]).Append("Hello");

            Assert.Throws<NotSupportedException>(() => df.Sum("Str"));
        }
    }
}
===== FILE: tests/LeichtFrame.Core.Tests/DataFrames/Operations/FilterTests.cs =====
namespace LeichtFrame.Core.Tests.DataFrameTests
{
    public class FilterTests
    {
        [Fact]
        public void Where_Filters_Rows_Correctly()
        {
            // Arrange
            var schema = new DataFrameSchema(new[] {
                new ColumnDefinition("Id", typeof(int)),
                new ColumnDefinition("City", typeof(string))
            });
            var df = DataFrame.Create(schema, 10);

            var id = (IntColumn)df["Id"];
            var city = (StringColumn)df["City"];

            // Add Data: 1=Berlin, 2=Munich, 3=Berlin, 4=Hamburg
            id.Append(1); city.Append("Berlin");
            id.Append(2); city.Append("Munich");
            id.Append(3); city.Append("Berlin");
            id.Append(4); city.Append("Hamburg");

            // Act: Filter City == "Berlin"
            var berlinDf = df.Where(row => row.Get<string>("City") == "Berlin");

            // Assert
            Assert.Equal(2, berlinDf.RowCount);
            Assert.Equal(1, berlinDf["Id"].Get<int>(0));
            Assert.Equal(3, berlinDf["Id"].Get<int>(1));
        }

        [Fact]
        public void Where_Handles_Nulls_In_Predicate()
        {
            var df = DataFrame.Create(new DataFrameSchema(new[] {
                new ColumnDefinition("Val", typeof(int), IsNullable: true)
            }), 5);
            var col = (IntColumn)df["Val"];

            col.Append(10);
            col.Append(null);
            col.Append(20);

            // Filter: Not null and > 15
            // We need to check if RowView is null-safe or if the user must check.
            // RowView.Get<int> throws on null if T is struct. 
            // Therefore better: use row.GetValue or row.IsNull?
            // User pattern: check null before access.

            var result = df.Where(row =>
            {
                // We use the untyped GetValue here for the null check or catch exception
                // Cleaner: Get the column and check IsNull? No, RowView abstracts that.
                // Solution: User uses Get<int?> (nullable int) if we support that, 
                // OR checks object value.

                object? val = row.GetValue(0);
                return val != null && (int)val > 15;
            });

            Assert.Equal(1, result.RowCount);
            Assert.Equal(20, result["Val"].Get<int>(0));
        }

        [Fact]
        public void Where_Creates_Deep_Copy()
        {
            // Proof that it is not a view (like Slice), but a real copy
            var df = DataFrame.Create(new DataFrameSchema(new[] { new ColumnDefinition("A", typeof(int)) }), 5);
            ((IntColumn)df["A"]).Append(100);

            var filtered = df.Where(r => true); // Copy all

            // Modify the copy
            ((IntColumn)filtered["A"]).SetValue(0, 999);

            // Original must remain unchanged
            Assert.Equal(100, df["A"].Get<int>(0));
        }
    }
}
===== FILE: tests/LeichtFrame.Core.Tests/DataFrames/Operations/GroupingTests.cs =====
namespace LeichtFrame.Core.Tests.DataFrameTests
{
    public class GroupingTests
    {
        [Fact]
        public void GroupBy_Strings_creates_Correct_Buckets()
        {
            // Arrange
            var schema = new DataFrameSchema(new[] {
                new ColumnDefinition("Dept", typeof(string)),
                new ColumnDefinition("Id", typeof(int))
            });
            var df = DataFrame.Create(schema, 10);

            var dept = (StringColumn)df["Dept"];
            dept.Append("Sales"); // 0
            dept.Append("IT");    // 1
            dept.Append("Sales"); // 2
            dept.Append("HR");    // 3
            dept.Append("IT");    // 4

            // Act
            var grouped = df.GroupBy("Dept");

            // Assert
            Assert.Equal(3, grouped.GroupMap.Count); // Sales, IT, HR

            // Check Sales bucket
            Assert.True(grouped.GroupMap.ContainsKey("Sales"));
            var salesIndices = grouped.GroupMap["Sales"];
            Assert.Equal(new[] { 0, 2 }, salesIndices);

            // Check IT bucket
            var itIndices = grouped.GroupMap["IT"];
            Assert.Equal(new[] { 1, 4 }, itIndices);
        }

        [Fact]
        public void GroupBy_Handles_Nulls_As_Separate_Group()
        {
            var df = DataFrame.Create(new DataFrameSchema(new[] {
                new ColumnDefinition("Cat", typeof(string), IsNullable: true)
            }), 5);
            var col = (StringColumn)df["Cat"];

            col.Append("A");
            col.Append(null);
            col.Append("A");
            col.Append(null);

            var grouped = df.GroupBy("Cat");

            Assert.Equal(2, grouped.GroupMap.Count); // "A" and NullKey

            // We need to check indirectly since NullKey is internal/private.
            // We iterate over keys and find the one that is not "A".
            var nullGroupKey = grouped.GroupMap.Keys.First(k => k is not string);
            var indices = grouped.GroupMap[nullGroupKey];

            Assert.Equal(new[] { 1, 3 }, indices);
        }

        [Fact]
        public void GroupBy_Integers_Works()
        {
            var df = DataFrame.Create(new DataFrameSchema(new[] { new ColumnDefinition("Num", typeof(int)) }), 5);
            var col = (IntColumn)df["Num"];
            col.Append(10);
            col.Append(20);
            col.Append(10);

            var grouped = df.GroupBy("Num");

            Assert.Equal(2, grouped.GroupMap.Count); // 2 Groups overall (10 and 20)
            Assert.Equal(2, grouped.GroupMap[10].Count); // Group 10 has 2 entries
            Assert.Single(grouped.GroupMap[20]); // Group 20 has exactly 1 entry
        }

        [Fact]
        public void Group_Count_Returns_Correct_DataFrame()
        {
            var df = DataFrame.Create(new DataFrameSchema(new[] { new ColumnDefinition("Dept", typeof(string)) }), 10);
            var col = (StringColumn)df["Dept"];
            col.Append("IT");
            col.Append("Sales");
            col.Append("IT");

            var result = df.GroupBy("Dept").Count();

            Assert.Equal(2, result.RowCount);

            // Verify Structure
            Assert.Equal("Dept", result.Columns[0].Name);
            Assert.Equal("Count", result.Columns[1].Name);

            // Verify Data (Order is not guaranteed with HashMap, so we find rows)
            // Simpler check for MVP:
            // "IT" -> 2, "Sales" -> 1

            // Quick workaround to verify content without Order-dependency logic:
            var itRow = result.Where(r => r.Get<string>("Dept") == "IT");
            Assert.Equal(2, itRow["Count"].Get<int>(0));
        }

        [Fact]
        public void Group_Sum_Calculates_Totals()
        {
            var schema = new DataFrameSchema(new[] {
                new ColumnDefinition("Id", typeof(int)),
                new ColumnDefinition("Val", typeof(double))
            });
            var df = DataFrame.Create(schema, 10);

            var id = (IntColumn)df["Id"];
            var val = (DoubleColumn)df["Val"];

            // Group 1: 10 + 20 = 30
            id.Append(1); val.Append(10.0);
            id.Append(1); val.Append(20.0);

            // Group 2: 5 = 5
            id.Append(2); val.Append(5.0);

            var result = df.GroupBy("Id").Sum("Val");

            Assert.Equal(2, result.RowCount);

            // Check Sum for ID 1
            var g1 = result.Where(r => r.Get<int>("Id") == 1);
            Assert.Equal(30.0, g1["Sum_Val"].Get<double>(0));
        }

        [Fact]
        public void Group_Sum_Handles_Null_Values_In_Data()
        {
            var df = DataFrame.Create(new DataFrameSchema(new[] {
                new ColumnDefinition("G", typeof(string)),
                new ColumnDefinition("V", typeof(int), IsNullable: true)
            }), 5);

            var g = (StringColumn)df["G"];
            var v = (IntColumn)df["V"];

            g.Append("A"); v.Append(10);
            g.Append("A"); v.Append(null); // Should be ignored
            g.Append("A"); v.Append(5);

            var result = df.GroupBy("G").Sum("V");

            Assert.Equal(15.0, result["Sum_V"].Get<double>(0));
        }
    }
}
===== FILE: tests/LeichtFrame.Core.Tests/DataFrames/Operations/JoinTests.cs =====
namespace LeichtFrame.Core.Tests.DataFrameTests
{
    public class JoinTests
    {
        [Fact]
        public void InnerJoin_Integers_Matches_Correctly()
        {
            // Left: Employees
            var left = DataFrame.Create(new DataFrameSchema(new[] {
                new ColumnDefinition("EmpId", typeof(int)),
                new ColumnDefinition("DeptId", typeof(int))
            }), 10);
            ((IntColumn)left["EmpId"]).Append(1); ((IntColumn)left["DeptId"]).Append(100);
            ((IntColumn)left["EmpId"]).Append(2); ((IntColumn)left["DeptId"]).Append(200);
            ((IntColumn)left["EmpId"]).Append(3); ((IntColumn)left["DeptId"]).Append(100);

            // Right: Departments
            var right = DataFrame.Create(new DataFrameSchema(new[] {
                new ColumnDefinition("DeptId", typeof(int)),
                new ColumnDefinition("DeptName", typeof(string))
            }), 10);
            ((IntColumn)right["DeptId"]).Append(100); ((StringColumn)right["DeptName"]).Append("IT");
            ((IntColumn)right["DeptId"]).Append(300); ((StringColumn)right["DeptName"]).Append("HR");

            // Join on DeptId
            var joined = left.Join(right, on: "DeptId", JoinType.Inner);

            // Expect 2 rows (Emp 1 and 3 match Dept 100)
            Assert.Equal(2, joined.RowCount);

            // Check Data
            Assert.Equal("IT", joined["DeptName"].Get<string>(0));
            Assert.Equal(1, joined["EmpId"].Get<int>(0));
            Assert.Equal(3, joined["EmpId"].Get<int>(1));
        }

        [Fact]
        public void InnerJoin_Strings_Matches_Correctly()
        {
            var left = DataFrame.Create(new DataFrameSchema(new[] { new ColumnDefinition("Key", typeof(string)) }), 5);
            ((StringColumn)left["Key"]).Append("A");
            ((StringColumn)left["Key"]).Append("B");

            var right = DataFrame.Create(new DataFrameSchema(new[] {
                new ColumnDefinition("Key", typeof(string)),
                new ColumnDefinition("Val", typeof(int))
            }), 5);
            ((StringColumn)right["Key"]).Append("A"); ((IntColumn)right["Val"]).Append(99);

            var joined = left.Join(right, on: "Key");

            Assert.Equal(1, joined.RowCount);
            Assert.Equal("A", joined["Key"].Get<string>(0));
            Assert.Equal(99, joined["Val"].Get<int>(0));
        }

        [Fact]
        public void InnerJoin_1_to_N_Explodes_Rows()
        {
            // Left: 1 Row with Key 1
            var left = DataFrame.Create(new DataFrameSchema(new[] { new ColumnDefinition("K", typeof(int)) }), 5);
            ((IntColumn)left["K"]).Append(1);

            // Right: 2 Rows with Key 1
            var right = DataFrame.Create(new DataFrameSchema(new[] {
                new ColumnDefinition("K", typeof(int)),
                new ColumnDefinition("V", typeof(string))
            }), 5);

            ((IntColumn)right["K"]).Append(1); ((StringColumn)right["V"]).Append("M1");
            ((IntColumn)right["K"]).Append(1); ((StringColumn)right["V"]).Append("M2");

            var joined = left.Join(right, on: "K");

            Assert.Equal(2, joined.RowCount);
            Assert.Equal("M1", joined["V"].Get<string>(0));
            Assert.Equal("M2", joined["V"].Get<string>(1));
        }
    }
}
===== FILE: tests/LeichtFrame.Core.Tests/DataFrames/Operations/SelectionTests.cs =====
namespace LeichtFrame.Core.Tests.DataFrames.Operations
{
    public class SelectionTests
    {
        [Fact]
        public void Select_Returns_Subset_Of_Columns()
        {
            // Arrange
            var schema = new DataFrameSchema(new[] {
                new ColumnDefinition("A", typeof(int)),
                new ColumnDefinition("B", typeof(int)),
                new ColumnDefinition("C", typeof(int))
            });
            var df = DataFrame.Create(schema, 10);

            // Act
            var selected = df.Select("A", "C");

            // Assert
            Assert.Equal(2, selected.ColumnCount);
            Assert.Equal("A", selected.Columns[0].Name);
            Assert.Equal("C", selected.Columns[1].Name);

            // Verify B is gone
            Assert.False(selected.TryGetColumn("B", out _));
        }

        [Fact]
        public void Select_Is_ZeroCopy_And_SharedReference()
        {
            // Arrange
            var df = DataFrame.Create(new DataFrameSchema(new[] { new ColumnDefinition("Val", typeof(int)) }), 5);
            var colOriginal = (IntColumn)df["Val"];
            colOriginal.Append(100);

            // Act
            var dfSelection = df.Select("Val");
            var colSelected = (IntColumn)dfSelection["Val"];

            // Assert 1: They are physically the same objects
            Assert.Same(colOriginal, colSelected);

            // Assert 2: Changes in the original are visible in the selection
            colOriginal.SetValue(0, 999);
            Assert.Equal(999, colSelected.Get(0));

            // Assert 3: Changes in the selection are visible in the original
            colSelected.SetValue(0, 555);
            Assert.Equal(555, colOriginal.Get(0));
        }

        [Fact]
        public void Select_Respects_Order()
        {
            var schema = new DataFrameSchema(new[] {
                new ColumnDefinition("A", typeof(int)),
                new ColumnDefinition("B", typeof(int))
            });
            var df = DataFrame.Create(schema, 10);

            // Select B first, then A
            var selected = df.Select("B", "A");

            Assert.Equal("B", selected.Columns[0].Name);
            Assert.Equal("A", selected.Columns[1].Name);
        }

        [Fact]
        public void Select_Throws_On_Missing_Column()
        {
            var df = DataFrame.Create(new DataFrameSchema(new[] { new ColumnDefinition("A", typeof(int)) }), 5);

            Assert.Throws<ArgumentException>(() => df.Select("Z"));
        }
    }
}
===== FILE: tests/LeichtFrame.Core.Tests/DataFrames/Operations/SlicingTests.cs =====
namespace LeichtFrame.Core.Tests.DataFrames.Operations
{
    public class SlicingTests
    {
        [Fact]
        public void Slice_Creates_Correct_Window_On_Data()
        {
            var df = DataFrame.Create(new DataFrameSchema(new[] { new ColumnDefinition("Num", typeof(int)) }), 10);
            var col = (IntColumn)df["Num"];
            for (int i = 0; i < 5; i++) col.Append(i * 10); // 0, 10, 20, 30, 40

            // Slice middle: index 1 to 3 (Length 2) -> [10, 20]
            var slice = df.Slice(1, 2);

            Assert.Equal(2, slice.RowCount);
            Assert.Equal(10, slice["Num"].Get<int>(0)); // Original Index 1
            Assert.Equal(20, slice["Num"].Get<int>(1)); // Original Index 2
        }

        [Fact]
        public void Slice_Is_ZeroCopy_WriteThrough()
        {
            var df = DataFrame.Create(new DataFrameSchema(new[] { new ColumnDefinition("Num", typeof(int)) }), 5);
            ((IntColumn)df["Num"]).Append(100);
            ((IntColumn)df["Num"]).Append(200);

            var slice = df.Slice(1, 1); // View on row 1 (Value 200)

            // Change value via Slice
            var sliceCol = (IColumn<int>)slice["Num"];
            sliceCol.SetValue(0, 999);

            // Verify Change in Original
            Assert.Equal(999, df["Num"].Get<int>(1));
        }

        [Fact]
        public void Head_And_Tail_Work_As_Expected()
        {
            var df = DataFrame.Create(new DataFrameSchema(new[] { new ColumnDefinition("Id", typeof(int)) }), 10);
            for (int i = 0; i < 10; i++) ((IntColumn)df["Id"]).Append(i);

            var head = df.Head(3);
            Assert.Equal(3, head.RowCount);
            Assert.Equal(0, head["Id"].Get<int>(0));
            Assert.Equal(2, head["Id"].Get<int>(2));

            var tail = df.Tail(2);
            Assert.Equal(2, tail.RowCount);
            Assert.Equal(8, tail["Id"].Get<int>(0));
            Assert.Equal(9, tail["Id"].Get<int>(1));
        }

        [Fact]
        public void Slice_Handles_Out_Of_Bounds_Gracefully()
        {
            var df = DataFrame.Create(new DataFrameSchema(new[] { new ColumnDefinition("A", typeof(int)) }), 5);
            ((IntColumn)df["A"]).Append(1); // 1 Row total

            var safeSlice = df.Slice(0, 100); // Request more than exists
            Assert.Equal(1, safeSlice.RowCount); // Should clamp to real count

            var emptySlice = df.Slice(100, 5); // Start way after end
            Assert.Equal(0, emptySlice.RowCount);
        }
    }
}
===== FILE: tests/LeichtFrame.Core.Tests/DataFrames/RowViewTests.cs =====
namespace LeichtFrame.Core.Tests.DataFrames
{
    public class RowViewTests
    {
        [Fact]
        public void RowView_Access_Works_Typed_And_Untyped()
        {
            // Setup
            using var intCol = new IntColumn("Age", 10);
            intCol.Append(42);

            using var strCol = new StringColumn("Name", 10);
            strCol.Append("Alice");

            var schema = new DataFrameSchema(new[] {
                new ColumnDefinition("Age", typeof(int)),
                new ColumnDefinition("Name", typeof(string))
            });

            var columns = new IColumn[] { intCol, strCol };
            var row = new RowView(0, columns, schema);

            // 1. Typed Access (via IColumn<T>.GetValue)
            Assert.Equal(42, row.Get<int>(0));
            Assert.Equal("Alice", row.Get<string>("Name"));

            // 2. Untyped Access (via IColumn.GetValue)
            Assert.Equal(42, row.GetValue(0));     // GetValue methode
            Assert.Equal("Alice", row["Name"]);    // Indexer
        }
    }
}
===== FILE: tests/LeichtFrame.Core.Tests/DataFrames/SchemaTests.cs =====
namespace LeichtFrame.Core.Tests.DataFrames;

public class SchemaTests
{
    [Fact]
    public void Can_Create_Schema_And_Lookup_Columns()
    {
        // Arrange
        var defs = new List<ColumnDefinition>
        {
            new("Id", typeof(int)),
            new("Name", typeof(string), IsNullable: true),
            new("Price", typeof(double))
        };

        // Act
        var schema = new DataFrameSchema(defs);

        // Assert
        Assert.Equal(3, schema.Columns.Count);

        Assert.True(schema.HasColumn("Id"));
        Assert.True(schema.HasColumn("Name"));
        Assert.False(schema.HasColumn("Address")); // Should not exist

        Assert.Equal(0, schema.GetColumnIndex("Id"));
        Assert.Equal(1, schema.GetColumnIndex("Name"));
    }

    [Fact]
    public void Duplicate_Column_Names_Should_Throw()
    {
        var defs = new List<ColumnDefinition>
        {
            new("Id", typeof(int)),
            new("Id", typeof(string)) // Duplicate
        };

        Assert.Throws<ArgumentException>(() => new DataFrameSchema(defs));
    }

    [Fact]
    public void Json_Serialization_Roundtrip_Works()
    {
        // Arrange
        var originalDefs = new List<ColumnDefinition>
        {
            new("Count", typeof(int)),
            new("IsActive", typeof(bool), IsNullable: true)
        };
        var originalSchema = new DataFrameSchema(originalDefs);

        // Act
        string json = originalSchema.ToJson();
        var loadedSchema = DataFrameSchema.FromJson(json);

        // Assert
        Assert.Equal(2, loadedSchema.Columns.Count);

        // Check first column
        Assert.Equal("Count", loadedSchema.Columns[0].Name);
        Assert.Equal(typeof(int), loadedSchema.Columns[0].DataType);
        Assert.False(loadedSchema.Columns[0].IsNullable);

        // Check second column
        Assert.Equal("IsActive", loadedSchema.Columns[1].Name);
        Assert.Equal(typeof(bool), loadedSchema.Columns[1].DataType);
        Assert.True(loadedSchema.Columns[1].IsNullable);
    }

    private class TestPoco
    {
        public int Id { get; set; }
        public string? Name { get; set; }
        public double Score { get; set; }
        public bool IsActive { get; set; }
    }

    [Fact]
    public void FromType_Generates_Correct_Schema_From_POCO()
    {
        // Act
        var schema = DataFrameSchema.FromType<TestPoco>();

        // Assert
        Assert.Equal(4, schema.Columns.Count);

        // Check Types & Names
        Assert.Equal(typeof(int), schema.GetColumnType("Id"));
        Assert.Equal(typeof(string), schema.GetColumnType("Name"));
        Assert.Equal(typeof(double), schema.GetColumnType("Score"));
        Assert.Equal(typeof(bool), schema.GetColumnType("IsActive"));

        // Check Nullability
        // Name is string? -> Nullable
        var nameCol = schema.Columns.First(c => c.Name == "Name");
        Assert.True(nameCol.IsNullable);

        // Id is int -> Not Nullable
        var idCol = schema.Columns.First(c => c.Name == "Id");
        Assert.False(idCol.IsNullable);
    }
}
===== FILE: tests/LeichtFrame.Core.Tests/GlobalUsings.cs =====
global using Xunit;
===== FILE: tests/LeichtFrame.Core.Tests/LeichtFrame.Core.Tests.csproj =====
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>

    <IsPackable>false</IsPackable>
    <IsTestProject>true</IsTestProject>

    <GenerateDocumentationFile>false</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);CS1591</NoWarn>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.6.0" />
    <PackageReference Include="xunit" Version="2.4.2" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.4.5">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="coverlet.collector" Version="6.0.0">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\src\LeichtFrame.Core\LeichtFrame.Core.csproj" />
  </ItemGroup>

</Project>

===== FILE: tests/LeichtFrame.Core.Tests/Memory/GrowthStrategyTests.cs =====
namespace LeichtFrame.Core.Tests.Memory
{
    public class GrowthStrategyTests
    {
        [Fact]
        public void IntColumn_Grows_From_Small_To_Large_Without_DataLoss()
        {
            // Start extremely small (Capacity 2)
            using var col = new IntColumn("Growth", 2);
            int count = 10_000;

            // Loop Insert
            for (int i = 0; i < count; i++)
            {
                col.Append(i);
            }

            // Assert: Everything still there?
            Assert.Equal(count, col.Length);

            // Check samples
            Assert.Equal(0, col.Get(0));
            Assert.Equal(5000, col.Get(5000));
            Assert.Equal(9999, col.Get(9999));
        }

        [Fact]
        public void StringColumn_Grows_And_Preserves_Nulls()
        {
            // Start small
            using var col = new StringColumn("StrGrowth", 4, isNullable: true);
            int count = 1000;

            for (int i = 0; i < count; i++)
            {
                if (i % 2 == 0)
                    col.Append($"Item {i}");
                else
                    col.Append(null);
            }

            Assert.Equal(count, col.Length);

            // Verify Integrity after multiple resizes
            for (int i = 0; i < count; i++)
            {
                if (i % 2 == 0)
                {
                    Assert.False(col.IsNull(i));
                    Assert.Equal($"Item {i}", col.Get(i));
                }
                else
                {
                    Assert.True(col.IsNull(i));
                    Assert.Null(col.Get(i));
                }
            }
        }

        [Fact]
        public void Explicit_EnsureCapacity_Triggering()
        {
            using var col = new DoubleColumn("Explicit", 10);

            // Manually increase capacity
            col.EnsureCapacity(1000);

            // Check without exposing internal fields:
            // If we now add 1000 items, no further resize should be necessary 
            // (hard to test black-box, but we test that it doesn't crash and retains data)

            col.Append(3.14);
            Assert.Equal(3.14, col.Get(0));
        }

        [Fact]
        public void BoolColumn_BitPacking_Survives_Growth()
        {
            // BoolColumn is special (bit manipulation)
            using var col = new BoolColumn("Bits", 8); // 1 byte

            // Fill 1000 bits (crossing many byte boundaries)
            for (int i = 0; i < 1000; i++)
            {
                col.Append(true);
            }

            Assert.Equal(1000, col.Length);
            Assert.True(col.AllTrue()); // Must still be true
        }
    }
}
===== FILE: tests/LeichtFrame.Core.Tests/Memory/NullBitmapTests.cs =====
namespace LeichtFrame.Core.Tests.Memory
{
    public class NullBitmapTests
    {
        [Fact]
        public void SetNull_SetsBit_Correctly()
        {
            using var bitmap = new NullBitmap(100);

            bitmap.SetNull(10);

            Assert.True(bitmap.IsNull(10));
            Assert.False(bitmap.IsNull(9));
            Assert.False(bitmap.IsNull(11));
        }

        [Fact]
        public void SetNotNull_ClearsBit_Correctly()
        {
            using var bitmap = new NullBitmap(100);
            bitmap.SetNull(50);
            Assert.True(bitmap.IsNull(50));

            bitmap.SetNotNull(50);
            Assert.False(bitmap.IsNull(50));
        }

        [Fact]
        public void BitLogic_Works_Across_WordBoundaries()
        {
            // A ulong has 64 bits. We test the transition from ulong[0] to ulong[1].
            using var bitmap = new NullBitmap(128);

            bitmap.SetNull(63); // Last bit in the first word
            bitmap.SetNull(64); // First bit in the second word

            Assert.True(bitmap.IsNull(63), "Index 63 failure");
            Assert.True(bitmap.IsNull(64), "Index 64 failure");
            Assert.False(bitmap.IsNull(62));
            Assert.False(bitmap.IsNull(65));
        }

        [Fact]
        public void Resize_Preserves_Existing_Bits()
        {
            using var bitmap = new NullBitmap(64);
            bitmap.SetNull(10);
            bitmap.SetNull(63);

            // Resize to something that requires a new ulong array
            bitmap.Resize(128);

            Assert.True(bitmap.IsNull(10));
            Assert.True(bitmap.IsNull(63));
            Assert.False(bitmap.IsNull(64)); // New area should be empty
        }

        [Fact]
        public void Supports_Large_Indexes_Without_Error()
        {
            // Criteria: "Bitmap behaves correctly for large indexes (e.g., 1 million entries)"
            int largeIndex = 1_000_000;

            // Start small
            using var bitmap = new NullBitmap(16);

            // Resize to large
            bitmap.Resize(largeIndex + 1);

            // Test bit at the end of the large range
            bitmap.SetNull(largeIndex);

            Assert.True(bitmap.IsNull(largeIndex));
            Assert.False(bitmap.IsNull(largeIndex - 1));
        }
    }
}
===== FILE: tests/LeichtFrame.Core.Tests/Mocks/SimpleMockColumn.cs =====
namespace LeichtFrame.Core.Tests.Mocks;

public class SimpleMockColumn<T> : Column<T>
{
    private T[] _data;
    private bool[] _nulls;
    private int _count;

    public SimpleMockColumn(string name, int length, bool isNullable = true)
        : base(name, isNullable)
    {
        if (length < 0) throw new ArgumentOutOfRangeException(nameof(length));
        _data = new T[length];
        _nulls = new bool[length];
        _count = length;
    }

    public override int Length => _count;

    public override ReadOnlyMemory<T> Values => _data.AsMemory(0, _count);

    public override T Get(int index)
    {
        if ((uint)index >= (uint)_count) throw new IndexOutOfRangeException(nameof(index));
        return _data[index];
    }

    public override void SetValue(int index, T value)
    {
        if (index < 0) throw new IndexOutOfRangeException(nameof(index));
        if (index >= _data.Length) EnsureCapacity(index + 1);
        _data[index] = value;
        _nulls[index] = false;
        if (index >= _count) _count = index + 1;
    }

    public override bool IsNull(int index)
    {
        if ((uint)index >= (uint)_count) throw new IndexOutOfRangeException(nameof(index));
        return _nulls[index];
    }

    public override void SetNull(int index)
    {
        if (index < 0) throw new IndexOutOfRangeException(nameof(index));
        if (index >= _data.Length) EnsureCapacity(index + 1);
        _nulls[index] = true;
        if (index >= _count) _count = index + 1;
    }

    public override void SetNotNull(int index)
    {
        if ((uint)index >= (uint)_count) throw new IndexOutOfRangeException(nameof(index));
        _nulls[index] = false;
    }

    public override void EnsureCapacity(int capacity)
    {
        if (capacity <= _data.Length) return;
        int newSize = Math.Max(capacity, Math.Max(4, _data.Length * 2));
        Array.Resize(ref _data, newSize);
        Array.Resize(ref _nulls, newSize);
    }

    public override void Append(T value)
    {
        if (_count >= _data.Length)
            EnsureCapacity(_count + 1);

        _data[_count] = value;
        _nulls[_count] = false;
        _count++;
    }

    public override IColumn CloneSubset(IReadOnlyList<int> indices)
    {
        var newCol = new SimpleMockColumn<T>(Name, indices.Count, IsNullable);

        for (int i = 0; i < indices.Count; i++)
        {
            int sourceIndex = indices[i];

            if (IsNullable && IsNull(sourceIndex))
            {
                newCol.SetNull(i);
                newCol.SetValue(i, default!);
            }
            else
            {
                newCol.SetValue(i, Get(sourceIndex));
            }
        }

        return newCol;
    }
}

===== FILE: tests/LeichtFrame.IO.Tests/Arrow/ArrowConverterTests.cs =====
using Apache.Arrow;
using Apache.Arrow.Types;
using LeichtFrame.Core;

namespace LeichtFrame.IO.Tests
{
    public class ArrowConverterTests
    {
        [Fact]
        public void ToDataFrame_Converts_RecordBatch_Correctly()
        {
            // 1. Build Arrow RecordBatch manually
            var schema = new Schema.Builder()
                .Field(f => f.Name("Id").DataType(Int32Type.Default))
                .Field(f => f.Name("Score").DataType(DoubleType.Default))
                .Field(f => f.Name("Name").DataType(StringType.Default))
                .Build();

            int length = 2;

            // Build Arrays
            var idBuilder = new Int32Array.Builder().Append(1).Append(2);
            var scoreBuilder = new DoubleArray.Builder().Append(10.5).AppendNull(); // Contains Null
            var nameBuilder = new StringArray.Builder().Append("Alice").Append("Bob");

            var batch = new RecordBatch(schema, new IArrowArray[]
            {
                idBuilder.Build(),
                scoreBuilder.Build(),
                nameBuilder.Build()
            }, length);

            // 2. Act: Convert to LeichtFrame
            var df = batch.ToDataFrame(); // Extension Method usage

            // 3. Assert
            Assert.Equal(2, df.RowCount);
            Assert.Equal(3, df.ColumnCount);

            // Check Int
            Assert.Equal(1, df["Id"].Get<int>(0));
            Assert.Equal(2, df["Id"].Get<int>(1));

            // Check Double (Nullable)
            Assert.Equal(10.5, df["Score"].Get<double>(0));
            Assert.True(df["Score"].IsNull(1));

            // Check String
            Assert.Equal("Alice", df["Name"].Get<string>(0));
            Assert.Equal("Bob", df["Name"].Get<string>(1));
        }

        [Fact]
        public void Roundtrip_DataFrame_ToArrow_ToDataFrame_Preserves_Data()
        {
            // Arrange
            var schema = new DataFrameSchema(new[] {
                new ColumnDefinition("Id", typeof(int)),
                new ColumnDefinition("Val", typeof(double), IsNullable: true),
                new ColumnDefinition("Flag", typeof(bool)),
                new ColumnDefinition("Text", typeof(string))
            });

            var original = DataFrame.Create(schema, 2);

            var cId = (IntColumn)original["Id"];
            var cVal = (DoubleColumn)original["Val"];
            var cFlag = (BoolColumn)original["Flag"];
            var cText = (StringColumn)original["Text"];

            cId.Append(1); cVal.Append(1.1); cFlag.Append(true); cText.Append("A");
            cId.Append(2); cVal.Append(null); cFlag.Append(false); cText.Append("B");

            // Act 1: Export to Arrow
            var batch = original.ToArrow();

            // Assert Arrow Structure (Basic check)
            Assert.Equal(2, batch.Length);
            Assert.Equal(4, batch.ColumnCount);
            Assert.IsType<Int32Array>(batch.Column("Id"));
            Assert.IsType<DoubleArray>(batch.Column("Val"));

            // Act 2: Import back to DataFrame
            var loaded = batch.ToDataFrame();

            // Assert Data Integrity
            Assert.Equal(1, loaded["Id"].Get<int>(0));
            Assert.Equal(1.1, loaded["Val"].Get<double>(0));
            Assert.True(loaded["Flag"].Get<bool>(0));
            Assert.Equal("A", loaded["Text"].Get<string>(0));

            Assert.True(loaded["Val"].IsNull(1)); // Check Null preservation
            Assert.False(loaded["Flag"].Get<bool>(1));
        }
    }
}
===== FILE: tests/LeichtFrame.IO.Tests/Csv/CsvReaderTests.cs =====
using System.Text;
using LeichtFrame.Core;

namespace LeichtFrame.IO.Tests
{
    public class CsvReaderTests
    {
        [Fact]
        public void Read_Parses_Simple_Csv_With_Header()
        {
            var csv = "Id,Name,Score\n1,Alice,99.5\n2,Bob,80.0";
            using var stream = new MemoryStream(Encoding.UTF8.GetBytes(csv));

            var schema = new DataFrameSchema(new[] {
                new ColumnDefinition("Id", typeof(int)),
                new ColumnDefinition("Name", typeof(string)),
                new ColumnDefinition("Score", typeof(double))
            });

            var df = CsvReader.Read(stream, schema);

            Assert.Equal(2, df.RowCount);
            Assert.Equal(1, df["Id"].Get<int>(0));
            Assert.Equal("Alice", df["Name"].Get<string>(0));
            Assert.Equal(99.5, df["Score"].Get<double>(0));
        }

        [Fact]
        public void Read_Handles_Nulls()
        {
            var csv = "Val\n100\n\n200";
            using var stream = new MemoryStream(Encoding.UTF8.GetBytes(csv));

            var schema = new DataFrameSchema(new[] {
                new ColumnDefinition("Val", typeof(int), IsNullable: true)
            });

            var df = CsvReader.Read(stream, schema);

            Assert.Equal(3, df.RowCount);
            Assert.Equal(100, df["Val"].Get<int>(0));
            Assert.True(df["Val"].IsNull(1));
            Assert.Equal(200, df["Val"].Get<int>(2));
        }

        [Fact]
        public void InferSchema_Detects_Int_Double_And_String()
        {
            string csvFile = Path.GetTempFileName();
            File.WriteAllText(csvFile, "Age,Weight,Name\n25,80.5,Alice\n30,90,Bob"); // 90 is int, 80.5 double

            try
            {
                var schema = CsvReader.InferSchema(csvFile);

                Assert.Equal(3, schema.Columns.Count);

                // Age: Only ints -> int
                Assert.Equal(typeof(int), schema.GetColumnType("Age"));

                // Weight: Mixed double and int -> double (Promotion)
                Assert.Equal(typeof(double), schema.GetColumnType("Weight"));

                // Name: String
                Assert.Equal(typeof(string), schema.GetColumnType("Name"));
            }
            finally
            {
                File.Delete(csvFile);
            }
        }

        [Fact]
        public void InferSchema_Detects_Nullability()
        {
            string csvFile = Path.GetTempFileName();
            File.WriteAllText(csvFile, "Val\n100\n\n200");

            try
            {
                var schema = CsvReader.InferSchema(csvFile);
                Assert.Equal(typeof(int), schema.GetColumnType("Val"));
                Assert.True(schema.Columns[0].IsNullable);
            }
            finally
            {
                File.Delete(csvFile);
            }
        }

        [Fact]
        public void InferSchema_Fallbacks_To_String_On_Conflict()
        {
            string csvFile = Path.GetTempFileName();
            File.WriteAllText(csvFile, "Mixed\n100\nHello"); // Int then String

            try
            {
                var schema = CsvReader.InferSchema(csvFile);
                Assert.Equal(typeof(string), schema.GetColumnType("Mixed"));
            }
            finally
            {
                File.Delete(csvFile);
            }
        }

        private class ProductCsv
        {
            public int Id { get; set; }
            public string Name { get; set; } = "";
            public double Price { get; set; }
        }

        [Fact]
        public void Read_Generic_Map_To_POCO_Schema_Correctly()
        {
            // Arrange
            var csv = "Id,Name,Price\n10,Laptop,999.99\n20,Mouse,19.50";
            using var stream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(csv));

            // Act: The "Gold Standard" Call
            var df = CsvReader.Read<ProductCsv>(stream);

            // Assert
            Assert.Equal(2, df.RowCount);

            // Verify Schema was inferred from POCO
            Assert.Equal(typeof(int), df.GetColumnType("Id"));
            Assert.Equal(typeof(string), df.GetColumnType("Name"));
            Assert.Equal(typeof(double), df.GetColumnType("Price"));

            // Verify Data
            Assert.Equal(10, df["Id"].Get<int>(0));
            Assert.Equal("Laptop", df["Name"].Get<string>(0));
            Assert.Equal(999.99, df["Price"].Get<double>(0));
        }
    }
}
===== FILE: tests/LeichtFrame.IO.Tests/Csv/CsvWriterTests.cs =====
using System.Text;
using LeichtFrame.Core;

namespace LeichtFrame.IO.Tests
{
    public class CsvWriterTests
    {
        [Fact]
        public void Write_Produces_Valid_String_Format()
        {
            // Arrange
            var schema = new DataFrameSchema(new[] {
                new ColumnDefinition("Id", typeof(int)),
                new ColumnDefinition("Price", typeof(double))
            });
            var df = DataFrame.Create(schema, 2);
            ((IntColumn)df["Id"]).Append(1); ((DoubleColumn)df["Price"]).Append(12.5);
            ((IntColumn)df["Id"]).Append(2); ((DoubleColumn)df["Price"]).Append(99.99);

            using var stream = new MemoryStream();

            // Act
            df.WriteCsv(stream);

            // Assert
            string csv = Encoding.UTF8.GetString(stream.ToArray());
            string[] lines = csv.Trim().Split(new[] { "\r\n", "\n" }, StringSplitOptions.None);

            Assert.Equal("Id,Price", lines[0]);
            Assert.Equal("1,12.5", lines[1]); // Verify Invariant Culture (Dot)
            Assert.Equal("2,99.99", lines[2]);
        }

        [Fact]
        public void Roundtrip_Write_Then_Read_Restores_Data()
        {
            // Arrange: Complex Data (Dates, Special Chars needing escaping)
            var original = DataFrame.Create(new DataFrameSchema(new[] {
                new ColumnDefinition("Date", typeof(DateTime)),
                new ColumnDefinition("Note", typeof(string))
            }), 1);

            var now = new DateTime(2023, 10, 05, 12, 30, 00);
            ((DateTimeColumn)original["Date"]).Append(now);
            ((StringColumn)original["Note"]).Append("Hello, World"); // Comma needs escaping!

            string tempFile = Path.GetTempFileName();
            try
            {
                // Act 1: Write
                original.WriteCsv(tempFile);

                // Act 2: Read Back
                var loaded = CsvReader.Read(tempFile, original.Schema);

                // Assert
                Assert.Equal(1, loaded.RowCount);
                Assert.Equal(now, loaded["Date"].Get<DateTime>(0));
                Assert.Equal("Hello, World", loaded["Note"].Get<string>(0)); // Quotes should be gone
            }
            finally
            {
                if (File.Exists(tempFile)) File.Delete(tempFile);
            }
        }
    }
}
===== FILE: tests/LeichtFrame.IO.Tests/GlobalUsings.cs =====
global using Xunit;
===== FILE: tests/LeichtFrame.IO.Tests/LeichtFrame.IO.Tests.csproj =====
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>

    <IsPackable>false</IsPackable>
    <IsTestProject>true</IsTestProject>

    <GenerateDocumentationFile>false</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);CS1591</NoWarn>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.6.0" />
    <PackageReference Include="xunit" Version="2.4.2" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.4.5">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="coverlet.collector" Version="6.0.0">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\src\LeichtFrame.IO\LeichtFrame.IO.csproj" />
    <ProjectReference Include="..\..\src\LeichtFrame.Core\LeichtFrame.Core.csproj" />
  </ItemGroup>

</Project>

===== FILE: tests/LeichtFrame.IO.Tests/Parquet/ParquetReaderTests.cs =====
using LeichtFrame.Core;
using Parquet;
using Parquet.Schema;
using Parquet.Data;

namespace LeichtFrame.IO.Tests
{
    public class ParquetReaderTests
    {
        private async Task<string> CreateTempParquetFile()
        {
            string path = Path.GetTempFileName();

            // Define Parquet Schema manually
            var schema = new ParquetSchema(
                new DataField<int>("Id"),
                new DataField<double?>("Value"), // Nullable
                new DataField<string>("Name")
            );

            // Columns
            var ids = new int[] { 1, 2 };
            var values = new double?[] { 10.5, null };
            var names = new string[] { "Alice", "Bob" };

            using var stream = File.OpenWrite(path);
            using var writer = await Parquet.ParquetWriter.CreateAsync(schema, stream);
            using var groupWriter = writer.CreateRowGroup();

            await groupWriter.WriteColumnAsync(new DataColumn(schema.DataFields[0], ids));
            await groupWriter.WriteColumnAsync(new DataColumn(schema.DataFields[1], values));
            await groupWriter.WriteColumnAsync(new DataColumn(schema.DataFields[2], names));

            return path;
        }

        [Fact]
        public async Task Read_Loads_Parquet_File_Correctly()
        {
            string path = await CreateTempParquetFile();

            try
            {
                // Act
                var df = ParquetReader.Read(path);

                // Assert Schema
                Assert.Equal(2, df.RowCount);
                Assert.Equal(3, df.ColumnCount);
                Assert.True(df.HasColumn("Id"));
                Assert.True(df.HasColumn("Value"));

                // Assert Data
                Assert.Equal(1, df["Id"].Get<int>(0));
                Assert.Equal(10.5, df["Value"].Get<double>(0));
                Assert.Equal("Alice", df["Name"].Get<string>(0));

                // Assert Null Handling
                Assert.Equal(2, df["Id"].Get<int>(1));
                Assert.True(df["Value"].IsNull(1)); // Should be null
                Assert.Equal("Bob", df["Name"].Get<string>(1));
            }
            finally
            {
                File.Delete(path);
            }
        }
    }
}
===== FILE: tests/LeichtFrame.IO.Tests/Parquet/ParquetWriterTests.cs =====
using LeichtFrame.Core;

namespace LeichtFrame.IO.Tests
{
    public class ParquetWriterTests
    {
        [Fact]
        public void Roundtrip_Write_Then_Read_Preserves_Data()
        {
            // Arrange
            var schema = new DataFrameSchema(new[] {
                new ColumnDefinition("Id", typeof(int)),
                new ColumnDefinition("Value", typeof(double), IsNullable: true),
                new ColumnDefinition("Name", typeof(string))
            });

            var original = DataFrame.Create(schema, 2);
            ((IntColumn)original["Id"]).Append(1);
            ((DoubleColumn)original["Value"]).Append(12.34);
            ((StringColumn)original["Name"]).Append("Test");

            ((IntColumn)original["Id"]).Append(2);
            ((DoubleColumn)original["Value"]).Append(null); // Check Nullable
            ((StringColumn)original["Name"]).Append("NullRow");

            string path = Path.GetTempFileName();

            try
            {
                // Act: Write
                original.WriteParquet(path);

                // Act: Read Back (using the Reader we built in C.2.1)
                // Note: Parquet might not preserve IsNullable=false for Int if not specified carefully, 
                // but logic maps nullable based on Parquet schema.
                var loaded = ParquetReader.Read(path);

                // Assert
                Assert.Equal(2, loaded.RowCount);

                Assert.Equal(1, loaded["Id"].Get<int>(0));
                Assert.Equal(12.34, loaded["Value"].Get<double>(0));
                Assert.Equal("Test", loaded["Name"].Get<string>(0));

                Assert.Equal(2, loaded["Id"].Get<int>(1));
                Assert.True(loaded["Value"].IsNull(1));
            }
            finally
            {
                File.Delete(path);
            }
        }
    }
}
